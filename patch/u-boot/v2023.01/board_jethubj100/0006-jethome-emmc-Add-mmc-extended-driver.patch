From f6bb2bb72f0604b18da948e7d24e14c7d3f1d966 Mon Sep 17 00:00:00 2001
From: Viacheslav Bocharov <adeep@lexina.in>
Date: Wed, 18 Jan 2023 11:37:12 +0300
Subject: [PATCH 06/17] jethome-emmc: Add mmc extended driver

Signed-off-by: Viacheslav Bocharov <adeep@lexina.in>
---
 drivers/mmc/Makefile             |    3 +
 drivers/mmc/aml_emmc_partition.c | 1715 ++++++++++++++++++++++++++++++
 drivers/mmc/mmc_aml.c            |  416 ++++++++
 drivers/mmc/storage_emmc.c       |  946 ++++++++++++++++
 4 files changed, 3080 insertions(+)
 create mode 100644 drivers/mmc/aml_emmc_partition.c
 create mode 100644 drivers/mmc/mmc_aml.c
 create mode 100644 drivers/mmc/storage_emmc.c

diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 3a664c2ebb..045c6359fd 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -4,7 +4,10 @@
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 
 obj-y += mmc.o
+obj-y += mmc_aml.o
 obj-$(CONFIG_$(SPL_)DM_MMC) += mmc-uclass.o
+obj-$(CONFIG_CMD_MMC) += storage_emmc.o
+obj-$(CONFIG_MMC_MESON_GX) += aml_emmc_partition.o
 
 ifdef CONFIG_$(SPL_TPL_)DM_MMC
 obj-$(CONFIG_$(SPL_TPL_)BOOTSTD) += mmc_bootdev.o
diff --git a/drivers/mmc/aml_emmc_partition.c b/drivers/mmc/aml_emmc_partition.c
new file mode 100644
index 0000000000..d27419db95
--- /dev/null
+++ b/drivers/mmc/aml_emmc_partition.c
@@ -0,0 +1,1715 @@
+/*
+ * Copyright 2016, Amlogic Inc
+ * yonghui.yu
+ *
+ * Based vaguely on the Linux code
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <mmc.h>
+#include <part.h>
+#include <memalign.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <div64.h>
+#include "mmc_private.h"
+#include <amlstorage/emmc_partitions.h>
+#include <amlogic/cpu_id.h>
+#include <part_efi.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+/* using mbr*/
+#define CONFIG_PTBL_MBR	(1)
+#if (CONFIG_PTBL_MBR)
+	/* cmpare partition name? */
+	#define CONFIG_CMP_PARTNAME	(0)
+	/* cmpare partition mask */
+	#define CONFIG_CMP_PARTMASK	(0)
+#else
+	#define CONFIG_CMP_PARTNAME	(1)
+	#define CONFIG_CMP_PARTMASK	(1)
+#endif
+/* debug info*/
+#define CONFIG_MPT_DEBUG 	(0)
+#define GPT_PRIORITY             (1)
+
+#define apt_err(fmt, ...) printf( "%s()-%d: " fmt , \
+                  __func__, __LINE__, ##__VA_ARGS__)
+
+#define apt_wrn(fmt, ...) printf( "%s()-%d: " fmt , \
+                  __func__, __LINE__, ##__VA_ARGS__)
+#if (CONFIG_MPT_DEBUG)
+/* for detail debug info */
+#define apt_info(fmt, ...) printf( "%s()-%d: " fmt , \
+                  __func__, __LINE__, ##__VA_ARGS__)
+#else
+#define apt_info(fmt, ...)
+#endif
+
+/* creat MBR for emmc */
+#define MAX_PNAME_LEN 	(16)
+#define MAX_PART_COUNT	(32)
+
+/*
+  Global offset of reserved partition is 36MBytes
+  since MMC_BOOT_PARTITION_RESERVED is 32MBytes and
+  MMC_BOOT_DEVICE_SIZE is 4MBytes.
+  MMC_RESERVED_SIZE is 64MBytes for now.
+  layout detail inside reserved partition.
+  0x000000 - 0x003fff: partition table
+  0x004000 - 0x03ffff: storage key area	(16k offset & 256k size)
+  0x400000 - 0x47ffff: dtb area  (4M offset & 512k size)
+  0x480000 - 64MBytes: resv for other usage.
+  ...
+ */
+/*
+#define RSV_DTB_OFFSET_GLB	(SZ_1M*40)
+#define RSV_DTB_SIZE		(512*1024UL)
+#define RSV_PTBL_OFFSET		(SZ_1M*0)
+#define RSV_PTBL_SIZE		(16*1024UL)
+#define RSV_SKEY_OFFSET		(16*1024UL)
+#define RSV_SKEY_SIZE		(256*1024UL)
+#define RSV_DTB_OFFSET		(SZ_1M*4)
+*/
+
+/* virtual partitions which are in "reserved" */
+#define MAX_MMC_VIRTUAL_PART_CNT	(5)
+
+
+/* BinaryLayout of partition table stored in rsv area */
+struct ptbl_rsv {
+    char magic[4];				/* MPT */
+    unsigned char version[12];	/* binary version */
+    int count;	/* partition count in using */
+    int checksum;
+    struct partitions partitions[MAX_MMC_PART_NUM];
+};
+
+/* partition table for innor usage*/
+struct _iptbl {
+	struct partitions *partitions;
+	int count;	/* partition count in use */
+};
+
+unsigned device_boot_flag = 0xff;
+bool is_partition_checked = false;
+
+#ifndef CONFIG_AML_MMC_INHERENT_PART
+/* fixme, name should be changed as aml_inherent_ptbl */
+struct partitions emmc_partition_table[] = {
+#ifndef CONFIG_AML_GPT
+	PARTITION_ELEMENT(MMC_BOOT_NAME, MMC_BOOT_DEVICE_SIZE, 0),
+#endif
+	PARTITION_ELEMENT(MMC_RESERVED_NAME, MMC_RESERVED_SIZE, 0),
+	/* prior partitions, same partition name with dts*/
+	/* partition size will be overide by dts*/
+	PARTITION_ELEMENT(MMC_CACHE_NAME, 0, 0),
+	PARTITION_ELEMENT(MMC_ENV_NAME, MMC_ENV_SIZE, 0),
+};
+
+struct virtual_partition virtual_partition_table[] = {
+    /* partition for name idx, off & size will not be used! */
+#if (CONFIG_PTBL_MBR)
+    VIRTUAL_PARTITION_ELEMENT(MMC_MBR_NAME, MMC_MBR_OFFSET, MMC_MBR_SIZE),
+#endif
+    VIRTUAL_PARTITION_ELEMENT(MMC_BOOT_NAME0, 0, 0),
+    VIRTUAL_PARTITION_ELEMENT(MMC_BOOT_NAME1, 0, 0),
+
+    /* virtual partition in reserved partition, take care off and size */
+#ifdef CONFIG_AML_PARTITION
+	VIRTUAL_PARTITION_ELEMENT(MMC_TABLE_NAME, MMC_TABLE_OFFSET, MMC_TABLE_SIZE),
+#endif
+	VIRTUAL_PARTITION_ELEMENT(MMC_KEY_NAME, EMMCKEY_RESERVE_OFFSET, MMC_KEY_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_PATTERN_NAME, CALI_PATTERN_OFFSET, CALI_PATTERN_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_MAGIC_NAME, MAGIC_OFFSET, MAGIC_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_RANDOM_NAME, RANDOM_OFFSET, RANDOM_SIZE),
+#ifndef DTB_BIND_KERNEL
+	VIRTUAL_PARTITION_ELEMENT(MMC_DTB_NAME, DTB_OFFSET, DTB_SIZE),
+#endif
+	VIRTUAL_PARTITION_ELEMENT(MMC_FASTBOOT_CONTEXT_NAME,
+			FASTBOOT_CONTEXT_OFFSET, FASTBOOT_CONTEXT_SIZE),
+	VIRTUAL_PARTITION_ELEMENT(MMC_DDR_PARAMETER_NAME,DDR_PARAMETER_OFFSET, DDR_PARAMETER_SIZE),
+};
+
+int get_emmc_partition_arraysize(void)
+{
+    return ARRAY_SIZE(emmc_partition_table);
+}
+
+int get_emmc_virtual_partition_arraysize(void)
+{
+    return ARRAY_SIZE(virtual_partition_table);
+}
+
+#endif
+
+void __attribute__((unused)) _dump_part_tbl(struct partitions *p, int count)
+{
+	int i = 0;
+	apt_info("count %d\n", count);
+	while (i < count) {
+		printf("%02d %10s %016llx %016llx\n", i, p[i].name, p[i].offset, p[i].size);
+		i++;
+	}
+	return;
+}
+
+static int _get_part_index_by_name(struct partitions *tbl,
+					   int cnt, const char *name)
+{
+	   int i=0;
+	   struct partitions *part = NULL;
+
+       while (i < cnt) {
+			   part = &tbl[i];
+               if (!strcmp(name, part->name)) {
+					   apt_info("find %s @ tbl[%d]\n", name, i);
+					   break;
+			   }
+			   i++;
+	   };
+       if (i == cnt) {
+			   i = -1;
+			   apt_wrn("do not find match in table %s\n", name);
+	   }
+	   return i;
+}
+
+
+
+static struct partitions *_find_partition_by_name(struct partitions *tbl,
+			int cnt, const char *name)
+{
+	int i = 0;
+	struct partitions *part = NULL;
+
+	while (i < cnt) {
+
+		part = &tbl[i];
+		if (!strcmp(name, part->name)) {
+			apt_info("find %s @ tbl[%d]\n", name, i);
+			break;
+		}
+		i++;
+	};
+	if (i == cnt) {
+		part = NULL;
+		apt_wrn("do not find match in table %s\n", name);
+	}
+	return part;
+}
+
+/* fixme, must called after offset was calculated. */
+static ulong _get_inherent_offset(const char *name)
+{
+	struct partitions *part;
+
+	part = _find_partition_by_name(emmc_partition_table,
+			get_emmc_partition_arraysize(), name);
+	if (NULL == part)
+		return -1;
+	else
+		return part->offset;
+}
+/* partition table (Emmc Partition Table) */
+struct _iptbl *p_iptbl_ept = NULL;
+
+/* trans byte into lba manner for rsv area read/write */
+#ifdef CONFIG_AML_PARTITION
+static ulong _mmc_rsv_read(struct mmc *mmc, ulong offset, ulong size, void * buffer)
+{
+	lbaint_t _blk, _cnt;
+	if (0 == size)
+		return 0;
+
+	_blk = offset / mmc->read_bl_len;
+	_cnt = size / mmc->read_bl_len;
+	_cnt = blk_dread(mmc_get_blk_desc(mmc), _blk, _cnt, buffer);
+
+	return (ulong)(_cnt * mmc->read_bl_len);
+}
+
+static ulong _mmc_rsv_write(struct mmc *mmc, ulong offset, ulong size, void * buffer)
+{
+	lbaint_t _blk, _cnt;
+	if (0 == size)
+		return 0;
+
+	_blk = offset / mmc->read_bl_len;
+	_cnt = size / mmc->read_bl_len;
+	_cnt = blk_dwrite(mmc_get_blk_desc(mmc), _blk, _cnt, buffer);
+
+	return (ulong)(_cnt * mmc->read_bl_len);
+}
+#endif
+
+
+static struct partitions * get_ptbl_from_dtb(struct mmc *mmc)
+{
+	struct partitions * ptbl = NULL;
+#ifdef CONFIG_AML_PARTITION
+#ifndef DTB_BIND_KERNEL
+	unsigned char * buffer = NULL;
+	ulong ret, offset;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+
+	/* try get dtb table from ddr, which may exsit while usb burning */
+	if (NULL == get_partitions()) {
+		/* if failed, try rsv dtb area then. */
+		buffer = malloc(vpart->size * DTB_COPIES);
+		if (NULL == buffer) {
+			apt_err("Can not alloc enough buffer\n");
+			goto _err;
+		}
+		offset = _get_inherent_offset(MMC_RESERVED_NAME) + vpart->offset;
+		ret = _mmc_rsv_read(mmc, offset, (vpart->size * DTB_COPIES), buffer);
+		if (ret != (vpart->size * DTB_COPIES)) {
+			apt_err("Can not alloc enough buffer\n");
+			goto _err1;
+		}
+		/* parse it */
+		if (get_partition_from_dts(buffer)) {
+			apt_err("get partition table from dts failed. try from internal dts\n");
+			if (buffer)
+				free(buffer);
+			buffer = (char*) env_get_ulong("fdtcontroladdr", 16, CONFIG_SYS_SDRAM_BASE + (16U<<20));
+			if (get_partition_from_dts(buffer)) {
+				apt_err("get partition table from internal dts failed.\n");
+				goto _err;
+			}
+			buffer = NULL;
+		}
+		/* double check part_table(glb) */
+		if (NULL == get_partitions()) {
+			goto _err1;
+		}
+		apt_info("get partition table from dts successfully\n");
+
+		if (buffer)
+			free(buffer);
+		buffer = NULL;
+	}
+#endif
+#endif
+	/* asign partition info to *ptbl */
+	ptbl = get_partitions();
+	return ptbl;
+#ifdef CONFIG_AML_PARTITION
+#ifndef DTB_BIND_KERNEL
+_err1:
+	if (buffer)
+		free(buffer);
+_err:
+	free (ptbl);
+	return NULL;
+#endif
+#endif
+}
+
+
+
+
+static struct partitions *is_prio_partition(struct _iptbl *list, struct partitions *part)
+{
+	int i;
+	struct partitions *plist = NULL;
+
+	if (list->count == 0)
+		goto _out;
+
+	apt_info("count %d\n", list->count);
+	for (i=0; i<list->count; i++) {
+		plist = &list->partitions[i];
+		apt_info("%d: %s, %s\n", i, part->name, plist->name);
+		if (!strcmp(plist->name, part->name)) {
+			apt_info("%s is prio in list[%d]\n", part->name, i);
+			break;
+		}
+	}
+	if (i == list->count)
+		plist = NULL;
+_out:
+	return plist;
+}
+
+/*  calculate offset of each partitions.
+	bottom is a flag for considering
+ */
+static int _calculate_offset(struct mmc *mmc, struct _iptbl *itbl, u32 bottom)
+{
+	int i;
+	struct partitions *part;
+	ulong  gap = PARTITION_RESERVED;
+	int ret = 0;
+
+	if (itbl->count <= 0)
+		return -1;
+	part = itbl->partitions;
+#if (CONFIG_MPT_DEBUG)
+	_dump_part_tbl(part, itbl->count);
+#endif
+
+#if CONFIG_AML_GPT
+	part->offset = RESERVED_GPT_OFFSET;
+#endif
+
+	if (!strcmp(part->name, "bootloader")) {
+		part->offset = 0;
+		gap = MMC_BOOT_PARTITION_RESERVED;
+	}
+	for (i=1; i<itbl->count; i++) {
+		/**/
+		part[i].offset = part[i-1].offset + part[i-1].size + gap;
+		/* check capicity overflow ?*/
+		if (((part[i].offset + part[i].size) > mmc->capacity) ||
+				(part[i].size == -1)) {
+			part[i].size = mmc->capacity - part[i].offset;
+			/* reserv space @ the bottom */
+			if (bottom && (part[i].size > MMC_BOTTOM_RSV_SIZE)) {
+				apt_info("reserv %d bytes at bottom\n", MMC_BOTTOM_RSV_SIZE);
+				part[i].size -= MMC_BOTTOM_RSV_SIZE;
+			}
+			break;
+		}
+		gap = PARTITION_RESERVED;
+	}
+	if (i < (itbl->count - 1)) {
+		apt_err("too large partition table for current emmc, overflow!\n");
+		ret = -1;
+	}
+#if (CONFIG_MPT_DEBUG)
+	_dump_part_tbl(part, itbl->count);
+#endif
+	return ret;
+}
+
+static void compose_ept(struct _iptbl *dtb, struct _iptbl *inh,
+			struct _iptbl *ept)
+{
+	int i;
+	struct partitions *partition = NULL;
+	struct partitions *dst, *src, *prio;
+
+	/* overide inh info by dts */
+	apt_info("dtb %p, inh %p, ept %p\n", dtb, inh, ept);
+	apt_info("ept->partitions %p\n", ept->partitions);
+	partition = ept->partitions;
+	apt_info("partition %p\n", partition);
+	for (i=0; i<MAX_PART_COUNT; i++) {
+		apt_info("i %d, ept->count %d\n", i, ept->count);
+		dst = &partition[ept->count];
+		src = (i < inh->count) ? &inh->partitions[i]:&dtb->partitions[i-inh->count];
+
+		prio = is_prio_partition(ept, src);
+		if (prio) {
+			/* overide prio partition by new */
+			apt_info("override %d: %s\n", ept->count, prio->name);
+			//*prio = *src;
+			dst = prio;
+		} else
+			ept->count ++;
+		*dst = *src;
+		if (-1 == src->size) {
+			apt_info("break! %s\n", src->name);
+			break;
+		}
+	}
+
+	return;
+}
+#ifdef CONFIG_AML_PARTITION
+static int _get_version(unsigned char * s)
+{
+	int version = 0;
+	if (!strncmp((char *)s, MMC_MPT_VERSION_2, sizeof(MMC_MPT_VERSION_2)))
+		version = 2;
+	else if (!strncmp((char *)s, MMC_MPT_VERSION_1, sizeof(MMC_MPT_VERSION_1)))
+		version = 1;
+	else
+		version = -1;
+
+	return version;
+}
+
+/*  calc checksum.
+	there's a bug on v1 which did not calculate all the partitios.
+ */
+static int _calc_iptbl_check_v2(struct partitions * part, int count)
+{
+	int ret = 0, i;
+	int size = count * sizeof(struct partitions) >> 2;
+	int *buf = (int *)part;
+
+	for (i = 0; i < size; i++)
+		ret +=buf[i];
+
+	return ret;
+}
+
+static int _calc_iptbl_check_v1(struct partitions *part, int count)
+{
+    int i, j;
+	u32 checksum = 0, *p;
+
+	for (i = 0; i < count; i++) {
+		p = (u32*)part;
+		/*BUG here, do not fix it!!*/
+		for (j = sizeof(struct partitions)/sizeof(checksum); j > 0; j--) {
+			checksum += *p;
+			p++;
+	    }
+    }
+
+	return checksum;
+}
+
+static int _calc_iptbl_check(struct partitions * part, int count, int version)
+{
+	if (1 == version)
+		return _calc_iptbl_check_v1(part, count);
+	else if (2 == version)
+		return _calc_iptbl_check_v2(part, count);
+	else
+		return -1;
+}
+
+/* ept is malloced out side */
+static int _cpy_iptbl(struct _iptbl * dst, struct _iptbl * src)
+{
+	int ret = 0;
+	if (!dst || !src) {
+		apt_err("invalid arg %s\n", !dst ? "dst" : "src");
+		ret = -1;
+		goto _out;
+	}
+	if (!dst->partitions || !src->partitions) {
+		apt_err("invalid arg %s->partitions\n", !dst ? "dst" : "src");
+		ret = -2;
+		goto _out;
+	}
+
+	dst->count = src->count;
+	memcpy(dst->partitions, src->partitions, sizeof(struct partitions) * src->count);
+
+_out:
+	return ret;
+}
+
+
+/* get ptbl from rsv area from emmc */
+static int get_ptbl_rsv(struct mmc *mmc, struct _iptbl *rsv)
+{
+	struct ptbl_rsv * ptbl_rsv = NULL;
+	uchar * buffer = NULL;
+	ulong size, offset;
+	int checksum, version, ret = 0;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_TABLE_NAME);
+
+	size = (sizeof(struct ptbl_rsv) + 511) / 512 * 512;
+	if (vpart->size < size) {
+		apt_err("too much partitons\n");
+		ret = -1;
+		goto _out;
+	}
+	buffer = malloc(size);
+	if (NULL == buffer) {
+		apt_err("no enough memory for ptbl rsv\n");
+		ret = -2;
+		goto _out;
+	}
+	/* read it from emmc. */
+	offset = _get_inherent_offset(MMC_RESERVED_NAME) + vpart->offset;
+	if (size != _mmc_rsv_read(mmc, offset, size, buffer)) {
+		apt_err("read ptbl from rsv failed\n");
+		ret = -3;
+		goto _out;
+	}
+
+	ptbl_rsv = (struct ptbl_rsv *) buffer;
+	apt_info("magic %3.3s, version %8.8s, checksum %x\n", ptbl_rsv->magic,
+			ptbl_rsv->version, ptbl_rsv->checksum);
+	/* fixme, check magic ?*/
+	if (strncmp(ptbl_rsv->magic, MMC_PARTITIONS_MAGIC, sizeof(MMC_PARTITIONS_MAGIC))) {
+		apt_err("magic faild %s, %3.3s\n", MMC_PARTITIONS_MAGIC, ptbl_rsv->magic);
+		ret = -4;
+		goto _out;
+	}
+	/* check version*/
+	version = _get_version(ptbl_rsv->version);
+	if (version < 0) {
+		apt_err("version faild %s, %3.3s\n", MMC_PARTITIONS_MAGIC, ptbl_rsv->magic);
+		ret = -5;
+		goto _out;
+	}
+	if (ptbl_rsv->count > MAX_MMC_PART_NUM) {
+		apt_err("invalid partition count %d\n", ptbl_rsv->count);
+		ret = -1;
+		goto _out;
+	}
+	/* check sum */
+	checksum = _calc_iptbl_check(ptbl_rsv->partitions, ptbl_rsv->count, version);
+	if (checksum != ptbl_rsv->checksum) {
+		apt_err("checksum faild 0x%x, 0x%x\n", ptbl_rsv->checksum, checksum);
+		ret = -6;
+		goto _out;
+	}
+
+	rsv->count = ptbl_rsv->count;
+	memcpy(rsv->partitions, ptbl_rsv->partitions, rsv->count * sizeof(struct partitions));
+
+_out:
+	if (buffer)
+		free (buffer);
+	return ret;
+}
+
+
+/* update partition tables from src
+	if success, return 0;
+	else, return 1
+	*/
+static int update_ptbl_rsv(struct mmc *mmc, struct _iptbl *src)
+{
+	struct ptbl_rsv *ptbl_rsv = NULL;
+	uchar *buffer;
+	ulong size, offset;
+	int ret = 0, version;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_TABLE_NAME);
+
+	size = (sizeof(struct ptbl_rsv) + 511) / 512 * 512;
+	buffer = malloc(size);
+	if (NULL == buffer) {
+		apt_err("no enough memory for ptbl rsv\n");
+		return -1;
+	}
+	memset(buffer, 0 , size);
+	/* version, magic and checksum */
+	ptbl_rsv = (struct ptbl_rsv *) buffer;
+	strcpy((char *)ptbl_rsv->version, MMC_MPT_VERSION);
+	strcpy(ptbl_rsv->magic, MMC_PARTITIONS_MAGIC);
+	if (src->count > MAX_MMC_PART_NUM) {
+		apt_err("too much partitions\n");
+		ret = -1;
+		goto _err;
+	}
+	ptbl_rsv->count = src->count;
+	memcpy(ptbl_rsv->partitions, src->partitions,
+		sizeof(struct partitions)*src->count);
+	version = _get_version(ptbl_rsv->version);
+	ptbl_rsv->checksum = _calc_iptbl_check(src->partitions, src->count, version);
+	/* write it to emmc. */
+	apt_info("magic %3.3s, version %8.8s, checksum %x\n", ptbl_rsv->magic, ptbl_rsv->version, ptbl_rsv->checksum);
+	offset = _get_inherent_offset(MMC_RESERVED_NAME) + vpart->offset;
+	if (_mmc_rsv_write(mmc, offset, size, buffer) != size) {
+		apt_err("write ptbl to rsv failed\n");
+		ret = -1;
+		goto _err;
+	}
+_err:
+	free (buffer);
+	return ret;
+}
+
+static void _free_iptbl(struct _iptbl *iptbl)
+{
+	if (iptbl && iptbl->partitions) {
+		free(iptbl->partitions);
+		iptbl->partitions = NULL;
+	}
+	if (iptbl) {
+		free(iptbl);
+		iptbl = NULL;
+	}
+
+	return;
+}
+
+#endif
+static int _cmp_partition(struct partitions *dst, struct partitions *src, int overide)
+{
+	int ret = 0;
+#if (CONFIG_CMP_PARTNAME)
+	if (strncmp(dst->name, src->name, sizeof(src->name)))
+		ret = -2;
+#endif
+	if (dst->size != src->size)
+		ret = -3;
+	if (dst->offset != src->offset)
+		ret = -4;
+#if (CONFIG_CMP_PARTMASK)
+	if (dst->mask_flags != src->mask_flags)
+		ret = -5;
+#endif
+
+	if (ret && (!overide)) {
+		apt_err("name: %10.10s<->%10.10s\n", dst->name, src->name);
+		apt_err("size: %llx<->%llx\n", dst->size, src->size);
+		apt_err("offset: %llx<->%llx\n", dst->offset, src->offset);
+		apt_err("mask: %08x<->%08x\n", dst->mask_flags, src->mask_flags);
+	}
+
+	if (overide) {
+		*dst = *src;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* compare partition tables
+	if same, do nothing then return 0;
+	else, print the diff ones and return -x
+	-1:count
+	-2:name
+	-3:size
+	-4:offset
+	*/
+static int _cmp_iptbl(struct _iptbl * dst, struct _iptbl * src)
+{
+	int ret = 0, i = 0;
+	struct partitions *dstp;
+	struct partitions *srcp;
+
+	if (dst->count != src->count) {
+		apt_err("partition count is not same %d:%d\n", dst->count, src->count);
+		ret = -1;
+		goto _out;
+	}
+
+	while (i < dst->count) {
+		dstp = &dst->partitions[i];
+		srcp = &src->partitions[i];
+		ret = _cmp_partition(dstp, srcp, 0);
+		if (ret) {
+			apt_err("partition %d has changed\n", i);
+			break;
+		}
+		i++;
+	}
+
+_out:
+	return ret;
+}
+
+
+/* iptbl buffer opt. */
+static int _zalloc_iptbl(struct _iptbl **_iptbl)
+{
+	int ret = 0;
+	struct _iptbl *iptbl;
+	struct partitions *partition = NULL;
+
+	partition = malloc(sizeof(struct partitions)*MAX_PART_COUNT);
+	if (NULL == partition) {
+		ret = -1;
+		apt_err("no enough memory for partitions\n");
+		goto _out;
+	}
+
+	iptbl = malloc(sizeof(struct _iptbl));
+	if (NULL == iptbl) {
+		ret = -2;
+		apt_err("no enough memory for ept\n");
+		free(partition);
+		goto _out;
+	}
+	memset(partition, 0, sizeof(struct partitions)*MAX_PART_COUNT);
+	memset(iptbl, 0, sizeof(struct _iptbl));
+
+	iptbl->partitions = partition;
+	apt_info("iptbl %p, partition %p, iptbl->partitions %p\n",
+		iptbl, partition, iptbl->partitions);
+	*_iptbl = iptbl;
+_out:
+	return ret;
+}
+
+
+/*
+ * fixme, need check space size later.
+ */
+
+static inline int le32_to_int(unsigned char *le32)
+{
+	return ((le32[3] << 24) +
+	    (le32[2] << 16) +
+	    (le32[1] << 8) +
+	     le32[0]
+	   );
+}
+
+static int test_block_type(unsigned char *buffer)
+{
+	int slot;
+	struct dos_partition *p;
+
+	if ((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
+	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
+		return (-1);
+	} /* no DOS Signature at all */
+	p = (struct dos_partition *)&buffer[DOS_PART_TBL_OFFSET];
+	for (slot = 0; slot < 3; slot++) {
+		if (p->boot_ind != 0 && p->boot_ind != 0x80) {
+			if (!slot &&
+			    (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],
+				     "FAT", 3) == 0 ||
+			     strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],
+				     "FAT32", 5) == 0)) {
+				return DOS_PBR; /* is PBR */
+			} else {
+				return -1;
+			}
+		}
+	}
+	return DOS_MBR;	    /* Is MBR */
+}
+
+//DOS_MBR OR DOS_PBR
+/*
+ * re-constructe iptbl from mbr&ebr infos.
+ * memory for  iptbl_mbr must be alloced outside.
+ *
+ */
+static void _construct_ptbl_by_mbr(struct mmc *mmc, struct _iptbl *iptbl_mbr)
+{
+	int ret,i;
+	int flag = 0;
+	lbaint_t read_offset = 0;
+	int part_num = 0;
+	int primary_num = 0;
+	uint64_t logic_start = 0;
+	uint64_t externed_start = 0;
+	struct dos_partition *pt;
+	struct partitions *partitions = iptbl_mbr->partitions;
+
+	apt_info("aml MBR&EBR debug...\n");
+	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, 512);
+	for (;;) {
+		apt_info("**%02d: read_offset %016llx\n", part_num, (uint64_t)read_offset<<9);
+		ret = blk_dread(mmc_get_blk_desc(mmc), read_offset, 1, buffer);
+		if (read_offset == 0)
+			flag = 1;
+		else
+			flag = 0;
+		/* debug code */
+		// print_buffer(0,buffer,1,512,16);
+		if (ret != 1) {
+			apt_err("ret %d fail to read current ebr&mbr from emmc! \n", ret);
+			break;
+		}
+		ret = test_block_type(buffer);
+		if (ret != 0 && ret != 1) {
+			apt_err("invalid magic value: 0x%02x%02x\n",
+				buffer[DOS_PART_MAGIC_OFFSET], buffer[DOS_PART_MAGIC_OFFSET + 1]);
+			break;
+		}
+
+		pt = (dos_partition_t *)(&buffer[0] + DOS_PART_TBL_OFFSET);
+		for (i = 0; i < 4; i++, pt++) {
+			if ( (pt->boot_ind == 0x00 || pt->boot_ind == 0x80) && pt->sys_ind == 0x83 ) {
+				//emmc_partition[part_num]->name = NULL;
+				partitions[part_num].offset = ((uint64_t)(le32_to_int(pt->start4)+read_offset) << 9ULL);
+				partitions[part_num].size = (uint64_t)le32_to_int(pt->size4) << 9ULL;
+				partitions[part_num].mask_flags = pt->sys_ind;
+
+				apt_info("--partition[%d]: %016llx, %016llx, 0x%08x \n",
+					part_num, partitions[part_num].offset,
+					partitions[part_num].size,
+					le32_to_int(pt->size4));
+				part_num++;
+				if ( flag )
+					primary_num++;
+			}else{/* get the next externed partition info */
+				if ( pt->boot_ind == 0x00 && pt->sys_ind == 0x05) {
+					logic_start = (uint64_t)le32_to_int (pt->start4);
+					//logic_size = (uint64_t)le32_to_int (pt->size4);
+				}
+			}
+		}
+		/* mbr & ebr debug infos */
+		apt_info("******%02d: read_offset=%016llx, logic_start=%016llx\n",
+			part_num,(uint64_t)read_offset*512ULL,logic_start*512ULL);
+
+		if (part_num == primary_num) {
+			externed_start = logic_start;
+			read_offset = externed_start;
+		}else
+			read_offset = externed_start + logic_start;
+		if (logic_start == 0)
+			break;
+		logic_start = 0;
+
+	}
+	iptbl_mbr->count = part_num;
+	apt_info("iptbl_mbr->count = %d\n", iptbl_mbr->count);
+
+	return;
+}
+
+static int __attribute__((unused)) _check_ptbl_mbr(struct mmc *mmc, struct _iptbl *ept)
+{
+	int ret = 0;
+	/* re-constructed by mbr */
+	struct _iptbl *iptbl_mbr = NULL, *ept2 = NULL;
+	struct partitions *partitions = NULL;
+	int i,j;
+
+	iptbl_mbr = malloc(sizeof(struct _iptbl));
+	if (NULL == iptbl_mbr) {
+		apt_err("no enough memory for iptbl_mbr\n");
+		return -1;
+	}
+	memset(iptbl_mbr , 0, sizeof(struct _iptbl));
+	partitions = (struct partitions *)malloc(sizeof(struct partitions) * DOS_PARTITION_COUNT);
+	if (NULL == partitions) {
+		apt_err("no enough memory for partitions\n");
+		free(iptbl_mbr);
+		return -1;
+	}
+	memset(partitions, 0, sizeof(struct partitions) * DOS_PARTITION_COUNT);
+	iptbl_mbr->partitions = partitions;
+
+	_construct_ptbl_by_mbr(mmc, iptbl_mbr);
+        if (iptbl_mbr->count > 0)
+	{
+		ret = 0;
+		goto _check_return;
+	}
+
+	ept2 = (struct _iptbl*) malloc(sizeof(struct _iptbl));
+	if (!ept2) 
+		return -1;
+
+	ept2 -> partitions = (struct partitions*) malloc (sizeof(struct partitions) * ept->count);
+	if (!ept2->partitions) 
+		return -1;
+	memset (ept2->partitions, 0, sizeof(struct partitions) * ept->count);
+	ept2 -> count = 0;
+
+	for (i=4,j=0;i<ept->count;i++)
+	{
+		apt_info("-!check partition name %s\n",ept->partitions[i].name);
+		memcpy(&ept2->partitions[j],&ept->partitions[i], sizeof(struct partitions));
+		j++;
+
+	}
+	ept2->count = j;
+
+	ret = _cmp_iptbl(iptbl_mbr, ept2);
+	if (ept2->partitions)
+		free (ept2->partitions);
+	if (ept2)
+		free (ept2);
+
+	if (partitions)
+		free(partitions);
+	if (iptbl_mbr)
+		free(iptbl_mbr);
+ _check_return:
+	apt_wrn("MBR is %s\n", ret?"Improper!":"OK!");
+	return ret;
+}
+
+/* construct a partition table entry of EBR */
+static int _construct_ebr_1st_entry(struct _iptbl *p_iptbl,struct dos_partition *p_ebr, int part_num )
+{
+	uint64_t start_offset = 0;
+	uint64_t logic_size = 0;
+
+	p_ebr->boot_ind = 0x00;
+	p_ebr->sys_ind = 0x83;
+	/* Starting = relative offset between this EBR sector and the first sector of the logical partition
+	* the gap between two partition is a fixed value of PARTITION_RESERVED ,otherwise the emmc partiton
+	* is different with reserved */
+	start_offset = PARTITION_RESERVED >> 9;
+	/* Number of sectors = total count of sectors for this logical partition */
+	// logic_size = (p_iptbl->partitions[part_num].size) >> 9ULL;
+	logic_size = lldiv(p_iptbl->partitions[part_num].size, 512);
+	apt_info("*** %02d: size 0x%016llx, logic_size 0x%016llx\n", part_num, p_iptbl->partitions[part_num].size, logic_size);
+	memcpy((unsigned char *)(p_ebr->start4), &start_offset, 4);
+	memcpy((unsigned char *)(p_ebr->size4), &logic_size, 4);
+	return 0;
+}
+
+static int _construct_ebr_2nd_entry(struct _iptbl *p_iptbl, struct dos_partition *p_ebr, int part_num)
+{
+	uint64_t start_offset = 0;
+	uint64_t logic_size = 0;
+
+	if ((part_num+2) > p_iptbl->count)
+		return 0;
+
+	p_ebr->boot_ind = 0x00;
+	p_ebr->sys_ind = 0x05;
+	/* Starting sector = LBA address of next EBR minus LBA address of extended partition's first EBR */
+	start_offset = (p_iptbl->partitions[part_num+1].offset - PARTITION_RESERVED -
+					(p_iptbl->partitions[3].offset - PARTITION_RESERVED)) >> 9;
+	/* total count of sectors for next logical partition, but count starts from the next EBR sector */
+	logic_size = (p_iptbl->partitions[part_num+1].size + PARTITION_RESERVED) >> 9;
+
+	memcpy((unsigned char *)(p_ebr->start4), &start_offset, 4);
+	memcpy((unsigned char *)(p_ebr->size4), &logic_size, 4);
+
+	return 0;
+}
+
+/* construct a partition table entry of MBR OR EBR */
+static int _construct_mbr_entry(struct _iptbl *p_iptbl, struct dos_partition *p_entry, int part_num)
+{
+	uint64_t start_offset = 0;
+	uint64_t primary_size = 0;
+	uint64_t externed_size = 0;
+	int i;
+	/* the entry is active or not */
+	if (part_num == 0 )
+		p_entry->boot_ind = 0x00;
+	else
+		p_entry->boot_ind = 0x00;
+
+	if (part_num == 3) {/* the logic partion entry */
+		/* the entry type */
+		p_entry->sys_ind = 0x05;
+		start_offset = (p_iptbl->partitions[3].offset - PARTITION_RESERVED) >> 9;
+		for ( i = 3;i< p_iptbl->count;i++)
+			externed_size = p_iptbl->partitions[i].size >> 9;
+
+		memcpy((unsigned char *)p_entry->start4, &start_offset, 4);
+		memcpy((unsigned char *)p_entry->size4, &externed_size, 4);
+	}else{/* the primary partion entry */
+		/* the entry type */
+		p_entry->sys_ind = 0x83;
+		start_offset = (p_iptbl->partitions[part_num].offset) >> 9;
+		primary_size = (p_iptbl->partitions[part_num].size)>>9;
+		memcpy((unsigned char *)p_entry->start4, &start_offset, 4);
+		memcpy((unsigned char *)p_entry->size4, &primary_size, 4);
+	}
+
+	return 0;
+}
+
+static int _construct_mbr_or_ebr(struct _iptbl *p_iptbl, struct dos_mbr_or_ebr *p_br,
+	int part_num, int type)
+{
+	int i;
+
+        apt_info("!!!++++ %0d(%0d) my count:%i\n",part_num, p_iptbl->count,p_iptbl->count<4?p_iptbl->count:4);
+	if (DOS_MBR == type) {
+		/* constuct a integral MBR */
+		for (i = 0; i< ((p_iptbl->count<4)?p_iptbl->count:4) ; i++)
+			_construct_mbr_entry(p_iptbl, &p_br->part_entry[i], i);
+
+	}else{
+		/* constuct a integral EBR */
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET] = 'F';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 1] = 'A';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 2] = 'T';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 3] = '3';
+		p_br->bootstart[DOS_PBR32_FSTYPE_OFFSET + 4] = '2';
+
+		_construct_ebr_1st_entry(p_iptbl, &p_br->part_entry[0], part_num);
+		_construct_ebr_2nd_entry(p_iptbl, &p_br->part_entry[1], part_num);
+	}
+
+	p_br->magic[0] = 0x55 ;
+	p_br->magic[1] = 0xAA ;
+	return 0;
+}
+
+static __attribute__((unused)) int _update_ptbl_mbr(struct mmc *mmc, struct _iptbl *p_iptbl)
+{
+	int ret = 0, start_blk = 0, blk_cnt = 1;
+	unsigned char *src;
+	int i,j;
+	struct dos_mbr_or_ebr *mbr;
+	struct _iptbl *ptb ;
+	struct _iptbl *ptb2;
+
+	ptb = p_iptbl;
+	ptb2 = (struct _iptbl*) malloc(sizeof(struct _iptbl));
+
+	ptb2 -> partitions = (struct partitions*) malloc (sizeof(struct partitions) * ptb->count);
+	memset (ptb2->partitions, 0, sizeof(struct partitions) * ptb->count);
+	ptb2 -> count = 0;
+
+	for (i=4,j=0;i<ptb->count;i++)
+	{
+		apt_info("-!check partition name %s\n",ptb->partitions[i].name);
+		memcpy(&ptb2->partitions[j],&ptb->partitions[i], sizeof(struct partitions));
+		j++;
+
+	}
+	ptb2->count = j;
+	ptb = ptb2;
+
+	mbr = malloc(sizeof(struct dos_mbr_or_ebr));
+
+	for (i=0;i<ptb->count;i++) {
+		apt_info("-update MBR-: partition[%02d]: %016llx - %016llx skipped:%s name:%s parts count:%02d\n",i,
+			ptb->partitions[i].offset, ptb->partitions[i].size, ptb->partitions[i].size==0? "yes" :"no", ptb->partitions[i].name, ptb->count);
+	}
+
+	for (i = 0;i < ptb->count;) {
+		apt_info("!!!!--- update_ptbl_mbr %02d (%02d)\n", i, ptb->count);
+		memset(mbr ,0 ,sizeof(struct dos_mbr_or_ebr));
+		if (i == 0) {
+			_construct_mbr_or_ebr(ptb, mbr, i, 0);
+			i = i+2;
+		} else
+			_construct_mbr_or_ebr(ptb, mbr, i, 2);
+		src = (unsigned char *)mbr;
+		apt_info("--%s(): %02d(%02d), off %x\n", __func__, i, ptb->count, start_blk);
+		ret = blk_dwrite(mmc_get_blk_desc(mmc), start_blk, blk_cnt, src);
+		i++;
+		if (ret != blk_cnt) {
+			apt_err("write current MBR failed! ret: %d != cnt: %d\n",ret,blk_cnt);
+			break;
+		}
+		start_blk = (ptb->partitions[i].offset - PARTITION_RESERVED) >> 9;
+		apt_info("!!!!end update_ptbl_mbr %02d (%02d)\n", i, ptb->count);
+	}
+	free(mbr);
+	free(ptb->partitions);
+	free(ptb);
+
+	ret = !ret;
+	if (ret)
+		apt_err("write MBR failed!\n");
+	else
+		apt_err("write MBR ok!!!!\n");
+
+	return ret;
+}
+
+#ifdef CONFIG_AML_GPT
+int is_gpt_changed(struct mmc *mmc, struct _iptbl *p_iptbl_ept)
+{
+	int i, k;
+	gpt_entry *gpt_pte = NULL;
+	size_t efiname_len;
+	struct _iptbl *ept = p_iptbl_ept;
+	struct partitions *partitions = ept->partitions;
+	int parts_num = ept->count;
+	uint64_t offset;
+	uint64_t size;
+	char name[PARTNAME_SZ];
+	int gpt_changed = 0;
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
+
+	if (!dev_desc) {
+		printf("%s: Invalid Argument(s)\n", __func__);
+		return 1;
+	}
+
+	if (is_gpt_valid(dev_desc, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				gpt_head, &gpt_pte) != 1) {
+		printf("%s: ***ERROR:Invalid GPT ***\n", __func__);
+		if (is_gpt_valid(dev_desc, (dev_desc->lba - 1),
+					gpt_head, &gpt_pte) != 1) {
+			printf("%s: ***ERROR: Invalid Backup GPT ***\n",
+					__func__);
+			return 1;
+		} else {
+			printf("%s: *** Using Backup GPT ***\n",
+					__func__);
+		}
+			//return 1;
+	}
+	for (i = 0; i < le32_to_cpu(gpt_head->num_partition_entries); i++) {
+		if (!is_pte_valid(&gpt_pte[i]))
+			break;
+
+		offset = le64_to_cpu(gpt_pte[i].starting_lba<<9ULL);
+		if (partitions[i].offset != offset) {
+			printf("Caution! GPT offset had been changed\n");
+			gpt_changed = 1;
+			break;
+		}
+
+		size = ((le64_to_cpu(gpt_pte[i].ending_lba)+1) -
+			le64_to_cpu(gpt_pte[i].starting_lba)) << 9ULL;
+		if (i == parts_num - 1) {
+			if ((partitions[i].size - GPT_TOTAL_SIZE) != size) {
+				printf("Caution! GPT size had been changed\n");
+				gpt_changed = 1;
+				break;
+			}
+		} else {
+		if (partitions[i].size != size) {
+			printf("Caution! GPT size had been changed\n");
+			gpt_changed = 1;
+			break;
+			}
+		}
+
+		/* partition name */
+		efiname_len = sizeof(gpt_pte[i].partition_name)
+			/ sizeof(efi_char16_t);
+
+		memset(name, 0, PARTNAME_SZ);
+		for (k = 0; k < efiname_len; k++)
+			name[k] = (char)gpt_pte[i].partition_name[k];
+		if (strcmp(name, partitions[i].name) != 0) {
+			printf("Caution! GPT name had been changed\n");
+			gpt_changed = 1;
+			break;
+		}
+
+	}
+	if ((i != parts_num) && (gpt_changed == 0)) {
+		gpt_changed = 1;
+		printf("Caution! GPT number had been changed\n");
+	}
+
+	free(gpt_pte);
+	return gpt_changed;
+}
+int is_gpt_broken(struct mmc *mmc)
+{
+	gpt_entry *gpt_pte = NULL;
+	int broken_status = 0;
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
+
+	if (!dev_desc) {
+		printf("%s: Invalid Argument(s)\n", __func__);
+		return 1;
+	}
+
+	if (is_gpt_valid(dev_desc, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				gpt_head, &gpt_pte) != 1) {
+		broken_status += 1;
+		printf("%s: ***ERROR:Invalid GPT ***\n", __func__);
+	}
+	if (is_gpt_valid(dev_desc, (dev_desc->lba - 1),
+				gpt_head, &gpt_pte) != 1) {
+		printf("%s: ***ERROR: Invalid Backup GPT ***\n",
+					__func__);
+		broken_status += 2;
+	}
+
+	if (broken_status != 3)
+		free(gpt_pte);
+	return broken_status;
+
+}
+
+int fill_ept_by_gpt(struct mmc *mmc, struct _iptbl *p_iptbl_ept)
+{
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
+	gpt_entry *gpt_pte = NULL;
+	int i, k;
+	size_t efiname_len, dosname_len;
+	struct _iptbl *ept = p_iptbl_ept;
+	struct partitions *partitions = ept->partitions;
+
+	if (!dev_desc) {
+		printf("%s: Invalid Argument(s)\n", __func__);
+		return 1;
+	}
+
+	if (is_gpt_valid(dev_desc, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				gpt_head, &gpt_pte) != 1) {
+		printf("%s: ***ERROR:Invalid GPT ***\n", __func__);
+		if (is_gpt_valid(dev_desc, (dev_desc->lba - 1),
+					gpt_head, &gpt_pte) != 1) {
+			printf("%s: ***ERROR: Invalid Backup GPT ***\n",
+					__func__);
+			return 1;
+		} else {
+			printf("%s: *** Using Backup GPT ***\n",
+					__func__);
+		}
+			//return 1;
+	}
+
+	for (i = 0; i < le32_to_cpu(gpt_head->num_partition_entries); i++) {
+		if (!is_pte_valid(&gpt_pte[i]))
+			break;
+
+		partitions[i].offset = le64_to_cpu(gpt_pte[i].starting_lba<<9ULL);
+		partitions[i].size = ((le64_to_cpu(gpt_pte[i].ending_lba)+1) -
+			le64_to_cpu(gpt_pte[i].starting_lba)) << 9ULL;
+		/* mask flag */
+		partitions[i].mask_flags = (uint32_t)le64_to_cpu(gpt_pte[i].attributes.fields.reserved);
+		/* partition name */
+		efiname_len = sizeof(gpt_pte[i].partition_name)
+			/ sizeof(efi_char16_t);
+		dosname_len = sizeof(partitions[i].name);
+
+		memset(partitions[i].name, 0, sizeof(partitions[i].name));
+		for (k = 0; k < min(dosname_len, efiname_len); k++)
+			partitions[i].name[k] = (char)gpt_pte[i].partition_name[k];
+
+	}
+	ept->count = i;
+	free(gpt_pte);
+	return 0;
+}
+
+void trans_ept_to_diskpart(struct _iptbl *ept, struct disk_partition *disk_part) {
+	struct partitions *part = ept->partitions;
+	int count = ept->count;
+	int i;
+	for (i = 0; i < count; i++) {
+		disk_part[i].start = part[i].offset >> 9;
+		strcpy((char *)disk_part[i].name, part[i].name);
+		/* store maskflag into type, 8bits ONLY! */
+		disk_part[i].type[0] = (uchar)part[i].mask_flags;
+	#ifdef CONFIG_PARTITION_TYPE_GUID
+		strcpy((char *)disk_part[i].type_guid, part[i].name);
+	#endif
+	#ifdef CONFIG_RANDOM_UUID
+		gen_rand_uuid_str(disk_part[i].uuid, UUID_STR_FORMAT_STD);
+	#endif
+		disk_part[i].bootable = 0;
+		if ( i == (count - 1))
+			disk_part[i].size = 0;
+		else
+			disk_part[i].size = (part[i].size) >> 9;
+	}
+	return;
+}
+
+
+
+
+#endif
+
+/***************************************************
+ *	init partition table for emmc device.
+ *	returns 0 means ok.
+ *			other means failure.
+ ***************************************************
+ *  work flows:
+ *	source of logic partition table(LPT) is from dts
+ *	no matter MACRO is on/off
+ *		1. try to get LPT from dtb
+ *			1.1 if dtb exist, compose ept by LPT&inh
+ *			1.2 if not, go ahead
+ *      2. try to get ept from emmc rsv partition
+ *			2.1 if not:
+ * 				2.1.1 when dtb exists
+ *					2.1.1.1 check ept with dtb
+ *					2.1.1.2 update rsv if needed
+ * 				2.1.1 without dtb, exit
+ *			2.2 if got:
+ *				2.2.1 try to reconstruct ept by MBR
+ *				2.2.2 check it with ept
+ *				2.2.3 update MBR if needed
+ ***************************************************
+ *	when normal boot:
+ *		without dtb, with rsv, with MBR
+ *  when blank emmc:
+ *		without dtb, without rsv, without MBR
+ *  when burning MBR on a blank emmc:
+ *		with dtb, without rsv, without MBR
+ *  when burning MBR on a emmc with rsv:
+ *		with dtb, with rsv, without MBR
+ *  when burning MBR on a emmc with rsv&MBR:
+ *		with dtb, with rsv, with MBR
+ ***************************************************/
+int mmc_device_init (struct mmc *mmc)
+{
+	int ret = 1;
+#if (CONFIG_PTBL_MBR)  || (!CONFIG_AML_PARTITION)
+	//cpu_id_t cpu_id = get_cpu_id();
+#endif
+	/* partition table from dtb/code/emmc rsv */
+	struct _iptbl iptbl_dtb, iptbl_inh;
+
+	/* calculate inherent offset */
+	iptbl_inh.count = get_emmc_partition_arraysize();
+	if (iptbl_inh.count) {
+		iptbl_inh.partitions = emmc_partition_table;
+		_calculate_offset(mmc, &iptbl_inh, 0);
+	}
+	apt_info("inh count %d\n",  iptbl_inh.count);
+#if (CONFIG_MPT_DEBUG)
+	apt_info("inherent partition table\n");
+	_dump_part_tbl(iptbl_inh.partitions, iptbl_inh.count);
+#endif
+	/* For re-entry */
+	if (NULL == p_iptbl_ept) {
+		ret = _zalloc_iptbl(&p_iptbl_ept);
+		if (ret)
+			goto _out;
+	} else {
+		p_iptbl_ept->count = 0;
+		memset(p_iptbl_ept->partitions, 0,
+			sizeof(struct partitions)*MAX_PART_COUNT);
+	}
+
+	/* try to get partition table from dtb(ddr or emmc) */
+	iptbl_dtb.partitions = get_ptbl_from_dtb(mmc);
+	/* construct ept by dtb if exist */
+	if (iptbl_dtb.partitions) {
+		iptbl_dtb.count = get_partition_count();
+		apt_info("dtb %p, count %d\n", iptbl_dtb.partitions, iptbl_dtb.count);
+		/* reserved partition must exist! */
+		if (iptbl_inh.count) {
+			compose_ept(&iptbl_dtb, &iptbl_inh, p_iptbl_ept);
+			if (0 == p_iptbl_ept->count) {
+				apt_err("compose partition table failed!\n");
+				goto _out;
+			}
+			/* calculate offset infos. considering GAPs */
+			if (_calculate_offset(mmc, p_iptbl_ept, 1)) {
+				goto _out;
+			}
+		#if (CONFIG_MPT_DEBUG)
+			apt_info("ept partition table\n");
+			_dump_part_tbl(p_iptbl_ept->partitions, p_iptbl_ept->count);
+		#endif
+		} else {
+			/* report fail, because there is no reserved partitions */
+			apt_err("compose partition table failed!\n");
+			ret = -1;
+			goto _out;
+		}
+	} else
+		apt_wrn("get partition table from dtb failed\n");
+#ifndef CONFIG_AML_PARTITION
+	if (0) { //(cpu_id.family_id < MESON_CPU_MAJOR_ID_G12B) {
+		printf("CONFIG_AML_PARTITION should define before G12B\n");
+		goto _out;
+	}
+#endif
+
+#ifdef CONFIG_AML_PARTITION
+	int update = 1;
+	struct _iptbl *p_iptbl_rsv = NULL;
+	/* try to get partiton table from rsv */
+	ret = _zalloc_iptbl(&p_iptbl_rsv);
+	if (ret)
+		goto _out;
+	ret = get_ptbl_rsv(mmc, p_iptbl_rsv);
+        apt_info("!!!! after call get_ptbl_rsv got %i parts\n",p_iptbl_rsv->count);
+
+	if (p_iptbl_rsv->count) {
+		/* dtb exist, p_iptbl_ept already inited */
+		if (iptbl_dtb.partitions) {
+			ret = _cmp_iptbl(p_iptbl_ept, p_iptbl_rsv);
+			if (!ret) {
+				update = 0;
+			}
+		} else {
+			/* without dtb, update ept with rsv */
+		        apt_info("!!!! call _cpy_iptbl from rsv to ept %i\n",p_iptbl_rsv->count);
+			_cpy_iptbl(p_iptbl_ept, p_iptbl_rsv);
+			update = 0;
+		}
+	} else {
+		/* without dtb& rsv */
+		if (!iptbl_dtb.partitions) {
+			apt_err("dtb&rsv are not exist, no LPT source\n");
+			ret = -9;
+			goto _out;
+		}
+	}
+
+	if (update && iptbl_dtb.partitions) {
+		apt_wrn("update rsv with dtb!\n");
+		ret = update_ptbl_rsv(mmc, p_iptbl_ept);
+	}
+#endif
+	//apt_wrn("ept source is %s\n", (ept_source == p_iptbl_ept)?"ept":"rsv");
+#if (CONFIG_PTBL_MBR)
+	/* 1st sector was reserved by romboot after gxl */
+	if (1) { //(cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+		if (_check_ptbl_mbr(mmc, p_iptbl_ept)) {
+			apt_info("!!!! after _check_ptbl_mbr, see %i ept parts, check result %i\n",p_iptbl_ept->count, _check_ptbl_mbr(mmc, p_iptbl_ept));
+			/*fixme, comaptible for mbr&ebr */
+			ret |= _update_ptbl_mbr(mmc, p_iptbl_ept);
+			apt_wrn("MBR Updated!\n");
+		}
+	}
+#endif
+#ifdef CONFIG_AML_GPT
+	char *str_disk_guid;
+	int gpt_priority = GPT_PRIORITY;
+	struct disk_partition *disk_partition;
+	int dcount = p_iptbl_ept->count;
+	struct blk_desc *dev_desc = mmc_get_blk_desc(mmc);
+	disk_partition = calloc(1, PAD_TO_BLOCKSIZE(sizeof(struct disk_partition) * dcount, dev_desc));
+	trans_ept_to_diskpart(p_iptbl_ept, disk_partition);
+	str_disk_guid = malloc(UUID_STR_LEN + 1);
+	if (str_disk_guid == NULL) {
+		free(disk_partition);
+		return -ENOMEM;
+	}
+#ifdef CONFIG_RANDOM_UUID
+	gen_rand_uuid_str(str_disk_guid, UUID_STR_FORMAT_STD);
+#endif
+	if (part_test_efi(mmc_get_blk_desc(mmc)) != 0) {
+		ret = gpt_restore(mmc_get_blk_desc(mmc), str_disk_guid, disk_partition, dcount);
+		printf("GPT IS RESTORED %s\n", ret ? "Failed!" : "OK!");
+	} else if (is_gpt_changed(mmc, p_iptbl_ept)) {
+		if (gpt_priority) {
+			fill_ept_by_gpt(mmc, p_iptbl_ept);
+			printf("and gpt has higher priority, so ept had been update\n");
+		} else {
+			gpt_restore(mmc_get_blk_desc(mmc), str_disk_guid, disk_partition, dcount);
+			printf("but EPT has higher priority, so gpt had been recover\n");
+		}
+	}
+
+	int broken_status = is_gpt_broken(mmc);
+	if (broken_status != 0 && broken_status != 3) {
+		fill_ept_by_gpt(mmc, p_iptbl_ept);
+		free(disk_partition);
+		dcount = p_iptbl_ept->count;
+		disk_partition = calloc(1, PAD_TO_BLOCKSIZE(sizeof(struct disk_partition) * dcount, dev_desc));
+		trans_ept_to_diskpart(p_iptbl_ept, disk_partition);
+		ret = gpt_restore(mmc_get_blk_desc(mmc), str_disk_guid, disk_partition, p_iptbl_ept->count);
+		if (broken_status == 1)
+			printf("The first gpt has been restore\n");
+		else if (broken_status == 2)
+			printf("The second gpt has been restore\n");
+		else
+			printf("Both gpt has been restore\n");
+	}
+
+	free(str_disk_guid);
+	free(disk_partition);
+#endif
+	/* init part again */
+	apt_info("!!!! init part again\n");
+	part_init(mmc_get_blk_desc(mmc));
+
+_out:
+#ifdef CONFIG_AML_PARTITION
+	if (p_iptbl_rsv)
+		_free_iptbl(p_iptbl_rsv);
+#endif
+	return ret;
+}
+
+
+struct partitions *find_mmc_partition_by_name (char const *name)
+{
+	struct partitions *partition = NULL;
+
+	apt_info("p_iptbl_ept %p\n", p_iptbl_ept);
+	if (NULL == p_iptbl_ept) {
+		goto _out;
+	}
+	partition = p_iptbl_ept->partitions;
+	partition = _find_partition_by_name(partition,
+			p_iptbl_ept->count, name);
+	apt_info("partition %p\n", partition);
+	if (!partition) {
+		partition = _find_partition_by_name(emmc_partition_table,
+			get_emmc_partition_arraysize(), name);
+	}
+	apt_info("partition %p\n", partition);
+_out:
+	return partition;
+}
+
+/*
+ find virtual partition in inherent table.
+*/
+int find_virtual_partition_by_name (char const *name, struct partitions *partition)
+{
+	int ret = 0;
+	ulong offset;
+	struct virtual_partition *vpart = aml_get_virtual_partition_by_name(MMC_DTB_NAME);
+	if (NULL == partition)
+		return -1;
+
+	offset = _get_inherent_offset(MMC_RESERVED_NAME);
+	if (-1 == offset) {
+		apt_err("can't find %s in inherent\n", MMC_RESERVED_NAME);
+		return -1;
+	}
+
+	if (!strcmp(name, "dtb")) {
+		strcpy(partition->name, name);
+		partition->offset = offset + vpart->offset;
+		partition->size = (vpart->size * DTB_COPIES);
+	}
+
+	return ret;
+}
+
+int find_dev_num_by_partition_name (char const *name)
+{
+	int dev = -1;
+
+	/* card */
+	if (!strcmp(name, MMC_CARD_PARTITION_NAME)) {
+		dev = 0;
+    } else { /* eMMC OR TSD */
+		/* partition name is valid */
+		if (find_mmc_partition_by_name(name)) {
+			dev = 1;
+		}
+	}
+	return dev;
+}
+
+static inline uint64_t get_part_size(struct partitions *part, int num)
+{
+    return part[num].size;
+}
+
+static inline uint64_t get_part_offset(struct partitions *part, int num)
+{
+    return part[num].offset;
+}
+
+static inline char * get_part_name(struct partitions *part, int num)
+{
+    return (char *)part[num].name;
+}
+
+int get_part_info_from_tbl(struct blk_desc *dev_desc,
+	int num, struct disk_partition *info)
+{
+    int ret = 0;
+    struct partitions *part;
+
+	if (NULL == p_iptbl_ept)
+        return -1;
+	if (num > (p_iptbl_ept->count-1))
+        return -1;
+    part = p_iptbl_ept->partitions;
+
+    /*get partition info by index! */
+    info->start = (lbaint_t)(get_part_offset(part, num)/dev_desc->blksz);
+    info->size = (lbaint_t)(get_part_size(part, num)/dev_desc->blksz);
+	info->blksz = dev_desc->blksz;
+    strcpy((char *)info->name, get_part_name(part, num));
+
+    return ret;
+}
+#if (CONFIG_MPT_DEBUG)
+void show_partition_info(struct disk_partition *info)
+{
+	printf("----------%s----------\n", __func__);
+	printf("name %10s\n", info->name);
+	printf("blksz " LBAFU "\n", info->blksz);
+	printf("sart %ld\n", info->start);
+	printf("size %ld\n", info->size);
+	printf("----------end----------\n");
+}
+#endif
+
+
+struct partitions *aml_get_partition_by_name(const char *name)
+{
+	struct partitions *partition = NULL;
+	partition = _find_partition_by_name(emmc_partition_table,
+			get_emmc_partition_arraysize(), name);
+	if (partition == NULL)
+		apt_wrn("do not find match in inherent table %s\n", name);
+	return partition;
+}
+
+struct virtual_partition *aml_get_virtual_partition_by_name(const char *name)
+{
+	int i = 0, cnt;
+	struct virtual_partition *part = NULL;
+	cnt = get_emmc_virtual_partition_arraysize();
+	while (i < cnt) {
+
+		part = &virtual_partition_table[i];
+		if (!strcmp(name, part->name)) {
+			apt_info("find %10s @ tbl[%d]\n", name, i);
+			break;
+		}
+		i++;
+	};
+	if (i == cnt) {
+		part = NULL;
+		apt_wrn("do not find match in table %10s\n", name);
+	}
+	return part;
+}
+
+int get_part_info_by_name(struct blk_desc *dev_desc,
+	const char *name, struct disk_partition *info)
+{
+	struct partitions *partition = NULL;
+	struct partitions virtual;
+	int ret = 0;
+	cpu_id_t cpu_id = get_cpu_id();
+
+	partition = find_mmc_partition_by_name((char *)name);
+	if (partition) {
+		info->start = (lbaint_t)(partition->offset/dev_desc->blksz);
+		info->size = (lbaint_t)(partition->size/dev_desc->blksz);
+		info->blksz = dev_desc->blksz;
+		strcpy((char *)info->name, partition->name);
+	} else if (!find_virtual_partition_by_name((char *)name, &virtual)) {
+		/* try virtual partitions */
+		apt_wrn("Got %s in virtual table\n", name);
+		info->start = (lbaint_t)(virtual.offset/dev_desc->blksz);
+		info->size = (lbaint_t)(virtual.size/dev_desc->blksz);
+		info->blksz = dev_desc->blksz;
+		strcpy((char *)info->name, virtual.name);
+	} else {
+		/* all partitions were tried, fail */
+		ret = -1;
+		goto _out;
+	}
+	/* for bootloader */
+	if ((0 == info->start) && (cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL)) {
+		info->start = 1;
+		info->size -= 1;
+	}
+
+#if (CONFIG_MPT_DEBUG)
+	show_partition_info(info);
+#endif
+_out:
+	return ret;
+}
+
+
+/*
+ * get the partition number by name
+ * return value
+ *     < 0 means no partition found
+ *     >= 0 means valid partition
+ */
+__weak int get_partition_num_by_name(char const *name)
+{
+	   int ret = -1;
+	   struct partitions *partition = NULL;
+
+       if (NULL == p_iptbl_ept)
+			   goto _out;
+	   partition = p_iptbl_ept->partitions;
+	   ret = _get_part_index_by_name(partition,
+					   p_iptbl_ept->count, name);
+_out:
+	   return ret;
+}
+
+/*
+ * get the partition info by number
+ * return value
+ *     < 0 means no partition found
+ *     >= 0 means valid partition
+ */
+__weak struct partitions *get_partition_info_by_num(const int num)
+{
+	struct partitions *partition = NULL;
+
+	if ((NULL == p_iptbl_ept)
+		|| (num >= p_iptbl_ept->count))
+		goto _out;
+	partition = &p_iptbl_ept->partitions[num];
+
+_out:
+	return partition;
+}
diff --git a/drivers/mmc/mmc_aml.c b/drivers/mmc/mmc_aml.c
new file mode 100644
index 0000000000..a9b0ff780f
--- /dev/null
+++ b/drivers/mmc/mmc_aml.c
@@ -0,0 +1,416 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2008, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the Linux code
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <errno.h>
+#include <mmc.h>
+#include <part.h>
+#include <power/regulator.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <linux/list.h>
+#include <linux/crc32.h>
+#include <rand.h>
+#include <div64.h>
+#include "mmc_private.h"
+#include <amlstorage/emmc_partitions.h>
+#include <amlstorage/partition_table.h>
+#include <amlogic/storage.h>
+#include <amlogic/asm/secure_apb.h>
+#include <amlogic/asm/sd_emmc.h>
+
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage);
+
+extern int emmc_probe(uint32_t init_flag);
+
+bool emmckey_is_access_range_legal (struct mmc *mmc, ulong start, lbaint_t blkcnt) {
+	ulong key_start_blk, key_end_blk;
+	u64 key_glb_offset;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	if (IS_MMC(mmc)) {
+		vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+		part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+		key_glb_offset = part->offset + vpart->offset;
+		key_start_blk = (key_glb_offset / MMC_BLOCK_SIZE);
+		key_end_blk = ((key_glb_offset + vpart->size) / MMC_BLOCK_SIZE - 1);
+		if (!(info_disprotect & DISPROTECT_KEY)) {
+			if ((key_start_blk <= (start + blkcnt -1))
+				&& (key_end_blk >= start)
+				&& (blkcnt != start)) {
+				pr_info("%s, keys %ld, keye %ld, start %ld, blkcnt %ld\n",
+						mmc->cfg->name, key_start_blk,
+						key_end_blk, start, blkcnt);
+				pr_err("Emmckey: Access range is illegal!\n");
+				return 0;
+			}
+		}
+	}
+	return 1;
+}
+
+int emmc_boot_chk(struct mmc *mmc)
+{
+	u32 val = 0;
+
+	if (strcmp(mmc->dev->name, "emmc"))
+		return 0;
+
+	val = readl(SEC_AO_SEC_GP_CFG0);
+	pr_info("SEC_AO_SEC_GP_CFG0 = %x\n", val);
+	if ((val & 0xf) == 0x1)
+		return 1;
+
+	return 0;
+}
+
+#if CONFIG_IS_ENABLED(MMC_TINY)
+static struct mmc mmc_static;
+struct mmc *find_mmc_device(int dev_num)
+{
+	return &mmc_static;
+}
+
+void mmc_do_preinit(void)
+{
+	struct mmc *m = &mmc_static;
+#ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
+	mmc_set_preinit(m, 1);
+#endif
+	if (m->preinit)
+		mmc_start_init(m);
+}
+
+struct blk_desc *mmc_get_blk_desc(struct mmc *mmc)
+{
+	return &mmc->block_dev;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+
+#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+static int mmc_wait_dat0(struct mmc *mmc, int state, int timeout)
+{
+	return -ENOSYS;
+}
+#endif
+
+__weak int board_mmc_getwp(struct mmc *mmc)
+{
+	return -1;
+}
+
+int mmc_getwp(struct mmc *mmc)
+{
+	int wp;
+
+	wp = board_mmc_getwp(mmc);
+
+	if (wp < 0) {
+		if (mmc->cfg->ops->getwp)
+			wp = mmc->cfg->ops->getwp(mmc);
+		else
+			wp = 0;
+	}
+
+	return wp;
+}
+
+__weak int board_mmc_getcd(struct mmc *mmc)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_MMC_TRACE
+void mmmc_trace_before_send(struct mmc *mmc, struct mmc_cmd *cmd)
+{
+	pr_info("CMD_SEND:%d\n", cmd->cmdidx);
+	pr_info("\t\tARG\t\t\t 0x%08X\n", cmd->cmdarg);
+}
+
+void mmmc_trace_after_send(struct mmc *mmc, struct mmc_cmd *cmd, int ret)
+{
+	int i;
+	u8 *ptr;
+
+	if (ret) {
+		pr_info("\t\tRET\t\t\t %d\n", ret);
+	} else {
+		switch (cmd->resp_type) {
+		case MMC_RSP_NONE:
+			pr_info("\t\tMMC_RSP_NONE\n");
+			break;
+		case MMC_RSP_R1:
+			pr_info("\t\tMMC_RSP_R1,5,6,7 \t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		case MMC_RSP_R1b:
+			pr_info("\t\tMMC_RSP_R1b\t\t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		case MMC_RSP_R2:
+			pr_info("\t\tMMC_RSP_R2\t\t 0x%08X \n",
+				cmd->response[0]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[1]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[2]);
+			pr_info("\t\t          \t\t 0x%08X \n",
+				cmd->response[3]);
+			pr_info("\n");
+			pr_info("\t\t\t\t\tDUMPING DATA\n");
+			for (i = 0; i < 4; i++) {
+				int j;
+				pr_info("\t\t\t\t\t%03d - ", i*4);
+				ptr = (u8 *)&cmd->response[i];
+				ptr += 3;
+				for (j = 0; j < 4; j++)
+					pr_info("%02X ", *ptr--);
+				pr_info("\n");
+			}
+			break;
+		case MMC_RSP_R3:
+			pr_info("\t\tMMC_RSP_R3,4\t\t 0x%08X \n",
+				cmd->response[0]);
+			break;
+		default:
+			pr_info("\t\tERROR MMC rsp not supported\n");
+			break;
+		}
+	}
+}
+
+#endif
+
+int mmc_get_ext_csd(struct mmc *mmc, u8 *ext_csd)
+{
+	return mmc_send_ext_csd(mmc, ext_csd);
+}
+
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+u8 ext_csd_w[] = {191, 187, 185, 183, 179, 178, 177, 175,
+					173, 171, 169, 167, 165, 164, 163, 162,
+					161, 156, 155, 143, 140, 136, 134, 133,
+					132, 131, 62, 59, 56, 52, 37, 34,
+					33, 32, 31, 30, 29, 22, 17, 16, 15};
+
+int mmc_set_ext_csd(struct mmc *mmc, u8 index, u8 value)
+{
+	int ret = -21, i;
+
+	for (i = 0; i < sizeof(ext_csd_w); i++) {
+		if (ext_csd_w[i] == index)
+			break;
+	}
+	if (i != sizeof(ext_csd_w))
+		ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, index, value);
+
+	return ret;
+}
+
+
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#ifdef MMC_SUPPORTS_TUNING
+static int mmc_execute_tuning(struct mmc *mmc, uint opcode)
+{
+	return -ENOTSUPP;
+}
+#endif
+
+static int mmc_set_ios(struct mmc *mmc)
+{
+	int ret = 0;
+
+	if (mmc->cfg->ops->set_ios)
+		ret = mmc->cfg->ops->set_ios(mmc);
+
+	return ret;
+}
+#endif
+
+struct mode_width_tuning {
+	enum bus_mode mode;
+	uint widths;
+#ifdef MMC_SUPPORTS_TUNING
+	uint tuning;
+#endif
+};
+
+#if CONFIG_IS_ENABLED(MMC_IO_VOLTAGE)
+int mmc_voltage_to_mv(enum mmc_voltage voltage)
+{
+	switch (voltage) {
+	case MMC_SIGNAL_VOLTAGE_000: return 0;
+	case MMC_SIGNAL_VOLTAGE_330: return 3300;
+	case MMC_SIGNAL_VOLTAGE_180: return 1800;
+	case MMC_SIGNAL_VOLTAGE_120: return 1200;
+	}
+	return -EINVAL;
+}
+
+static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
+{
+	int err;
+
+	if (mmc->signal_voltage == signal_voltage)
+		return 0;
+
+	mmc->signal_voltage = signal_voltage;
+	err = mmc_set_ios(mmc);
+	if (err)
+		pr_debug("unable to set voltage (err %d)\n", err);
+
+	return err;
+}
+#else
+static inline int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
+{
+	return 0;
+}
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+/* board-specific MMC power initializations. */
+__weak void board_mmc_power_init(void)
+{
+}
+#endif
+
+#ifdef CONFIG_CMD_BKOPS_ENABLE
+int mmc_set_bkops_enable(struct mmc *mmc)
+{
+	int err;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err) {
+		puts("Could not get ext_csd register values\n");
+		return err;
+	}
+
+	if (!(ext_csd[EXT_CSD_BKOPS_SUPPORT] & 0x1)) {
+		puts("Background operations not supported on device\n");
+		return -EMEDIUMTYPE;
+	}
+
+	if (ext_csd[EXT_CSD_BKOPS_EN] & 0x1) {
+		puts("Background operations already enabled\n");
+		return 0;
+	}
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BKOPS_EN, 1);
+	if (err) {
+		puts("Failed to enable manual background operations\n");
+		return err;
+	}
+
+	puts("Enabled manual background operations\n");
+
+	return 0;
+}
+#endif
+
+extern unsigned long blk_dwrite(struct blk_desc *block_dev, lbaint_t start,
+		lbaint_t blkcnt, const void *buffer);
+
+int mmc_key_write(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
+{
+	ulong start, start_blk, blkcnt, ret;
+	unsigned char * temp_buf = buf;
+	int i = 2, dev = EMMC_DTB_DEV;
+	struct partitions * part = NULL;
+	struct mmc *mmc;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+
+	mmc = find_mmc_device(dev);
+
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	info_disprotect |= DISPROTECT_KEY;
+	do {
+		ret = blk_dwrite(mmc_get_blk_desc(mmc), start_blk, blkcnt, temp_buf);
+		if (ret != blkcnt) {
+			pr_err("[%s] %d, mmc_bwrite error\n",
+				__func__, __LINE__);
+			return 1;
+		}
+		start_blk += vpart->size / MMC_BLOCK_SIZE;
+	} while (--i);
+	info_disprotect &= ~DISPROTECT_KEY;
+	return 0;
+}
+
+extern unsigned long blk_derase(struct blk_desc *block_dev, lbaint_t start,
+		lbaint_t blkcnt);
+
+int mmc_key_erase(void)
+{
+	ulong start, start_blk, blkcnt, ret;
+	struct partitions * part = NULL;
+	struct virtual_partition *vpart = NULL;
+	struct mmc *mmc;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	int dev = EMMC_DTB_DEV;
+
+	mmc = find_mmc_device(dev);
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (vpart->size / MMC_BLOCK_SIZE) * 2;//key and backup key
+	info_disprotect |= DISPROTECT_KEY;
+	ret = blk_derase(mmc_get_blk_desc(mmc), start_blk, blkcnt);
+	info_disprotect &= ~DISPROTECT_KEY;
+	if (ret) {
+		pr_err("[%s] %d mmc_berase error\n",
+				__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+
+int mmc_key_read(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
+{
+	ulong start, start_blk, blkcnt, ret;
+	int dev = EMMC_DTB_DEV;
+	unsigned char *temp_buf = buf;
+	struct partitions * part = NULL;
+	struct mmc *mmc;
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(MMC_KEY_NAME);
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+
+	mmc = find_mmc_device(dev);
+	*actual_lenth =  0x40000;/*key size is 256KB*/
+	start = part->offset + vpart->offset;
+	start_blk = (start / MMC_BLOCK_SIZE);
+	blkcnt = (size / MMC_BLOCK_SIZE);
+	info_disprotect |= DISPROTECT_KEY;
+	ret = blk_dread(mmc_get_blk_desc(mmc), start_blk, blkcnt, temp_buf);
+	info_disprotect &= ~DISPROTECT_KEY;
+	if (ret != blkcnt) {
+		pr_err("[%s] %d, mmc_bread error\n",
+			__func__, __LINE__);
+		return 1;
+	}
+	return 0;
+}
+
+
+
diff --git a/drivers/mmc/storage_emmc.c b/drivers/mmc/storage_emmc.c
new file mode 100644
index 0000000000..48519a6eea
--- /dev/null
+++ b/drivers/mmc/storage_emmc.c
@@ -0,0 +1,946 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+#include <amlogic/storage.h>
+#include <amlstorage/partition_table.h>
+#include <amlstorage/emmc_partitions.h>
+#include <amlogic/cpu_id.h>
+#include <amlogic/asm/bl31_apis.h>
+#include <linux/compat.h>
+#include <amlogic/aml_mmc.h>
+
+#include <asm/global_data.h>
+#include <dm/pinctrl.h>
+
+
+#define USER_PARTITION 0
+#define BOOT0_PARTITION 1
+#define BOOT1_PARTITION 2
+#define RPMB_PARTITION 3
+
+#define NOMAL_INIT 0
+#define ERASE_ALL 3
+#define ERASE_RESERVED 2
+
+#define GXB_START_BLK   0
+#define GXL_START_BLK   1
+#define STORAGE_EMMC 1
+/* max 2MB for emmc in blks */
+#define UBOOT_SIZE  (0x1000)
+#define BLOCK_SIZE 512
+
+
+
+
+
+extern int find_dev_num_by_partition_name (char const *name);
+extern struct partitions *get_partition_info_by_num(const int num);
+extern bool emmckey_is_protected(struct mmc *mmc);
+extern int info_disprotect;
+extern int dtb_read(void *addr);
+extern int dtb_write(void *addr);
+extern int renew_partition_tbl(unsigned char *buffer);
+
+static int storage_range_check(struct mmc *mmc,char const *part_name,loff_t offset, size_t *size,loff_t *off) {
+
+	struct partitions *part_info = NULL;
+
+	//cpu_id_t cpu_id = get_cpu_id();
+
+
+	if (strcmp(part_name, "bootloader") == 0) {
+		*off = 0;
+		if (1) { //if (cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+			*off += 512;
+		}
+		if (*size == 0) {
+			*size =mmc->capacity_boot;
+			if (1) { //if (cpu_id.family_id >= MESON_CPU_MAJOR_ID_GXL) {
+				*size = *size - 512;
+			}
+		}
+	} else {
+		part_info = find_mmc_partition_by_name(part_name);
+		if (!part_info) {
+			printf("error partition name!\n");
+			return 1;
+		}
+		if ((part_info->mask_flags & PART_PROTECT_FLAG) &&
+			!(info_disprotect & DISPROTECT_KEY)) {
+				printf("%s is protected, pls open it in Dts\n",
+				part_info->name);
+				return 1;
+		}
+
+		*off = part_info->offset+offset;
+		if (offset >= part_info->size) {
+			printf("Start address out #%s# partition'address region,(off < 0x%llx)\n",
+						part_name, part_info->size);
+			return 1;
+		}
+		if ((*off+*size) > (part_info->size+part_info->offset)) {
+			printf("End address exceeds #%s# partition,(offset = 0x%llx,size = 0x%llx)\n",
+						part_name, part_info->offset,part_info->size);
+			return 1;
+		}
+
+		if (*size == 0) {
+			*size = part_info->size - offset;
+		}
+	}
+	return 0;
+}
+
+
+
+static int storage_rsv_range_check(char const *part_name, size_t *size,loff_t *off) {
+
+	struct partitions *part = NULL;
+	struct virtual_partition *vpart = NULL;
+
+
+	vpart = aml_get_virtual_partition_by_name(part_name);
+
+	if (!vpart) {
+		printf("error partition name!\n");
+		return 1;
+	}
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	if (!part) {
+		printf("error partition name!\n");
+		return 1;
+	}
+	*off = part->offset + vpart->offset;
+	if ((*size) > vpart->size) {
+		printf("End address exceeds #%s# partition,(offset = 0x%llx,size = 0x%llx)\n",
+						part_name, vpart->offset,vpart->size);
+		return 1;
+	}
+	if (*size == 0)
+		*size = vpart->size;
+	return 0;
+}
+
+
+static int storage_byte_read(struct mmc *mmc,loff_t off, size_t  size,void *addr) {
+
+	int blk_shift = 0;
+	u64 cnt = 0, n = 0, blk = 0, sz_byte = 0;
+	ulong start_blk;
+	void *addr_tmp;
+	void *addr_byte;
+
+	blk_shift =  ffs(mmc->read_bl_len) - 1;
+	blk = off >>  blk_shift ;
+	cnt = size >>  blk_shift ;
+	sz_byte = size - ((cnt) << blk_shift) ;
+	mmc_init(mmc);
+
+	pr_info("blk:%lld   cnt:%lld \n",blk,cnt);
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if ((n == cnt) && (sz_byte != 0)) {
+	   /*printf("sz_byte=%#llx bytes\n",sz_byte);*/
+	   addr_tmp = malloc(mmc->read_bl_len);
+	   addr_byte = (void *)(addr+cnt*(mmc->read_bl_len));
+	   start_blk = blk+cnt;
+
+	   if (addr_tmp == NULL) {
+		   printf("mmc read: malloc fail\n");
+		   return 1;
+	   }
+
+	   if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+		   free(addr_tmp);
+		   printf("mmc read 1 block fail\n");
+		   return 1;
+	   }
+
+	   memcpy(addr_byte, addr_tmp, sz_byte);
+	   free(addr_tmp);
+	}
+	return (n == cnt) ? 0 : 1;
+
+
+}
+
+static int storage_byte_write(struct mmc *mmc,loff_t off, size_t  size,void *addr) {
+
+	int blk_shift = 0;
+	u64 cnt = 0, n = 0, blk = 0, sz_byte = 0;
+
+	blk_shift =  ffs(mmc->read_bl_len) - 1;
+	blk = off >>  blk_shift ;
+	cnt = size >>  blk_shift ;
+	sz_byte = size - ((cnt) << blk_shift);
+	mmc_init(mmc);
+	pr_info("blk:%lld   cnt:%lld \n",blk,cnt);
+
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	if ((n == cnt) && (sz_byte != 0)) {
+		// printf("sz_byte=%#llx bytes\n",sz_byte);
+		void *addr_tmp = malloc(mmc->write_bl_len);
+		void *addr_byte = (void*)(addr+cnt*(mmc->write_bl_len));
+		ulong start_blk = blk+cnt;
+
+		if (addr_tmp == NULL) {
+			printf("mmc write: malloc fail\n");
+			return 1;
+		}
+
+		if (blk_dread(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // read 1 block
+			free(addr_tmp);
+			printf("mmc read 1 block fail\n");
+			return 1;
+		}
+
+		memcpy(addr_tmp, addr_byte, sz_byte);
+		if (blk_dwrite(mmc_get_blk_desc(mmc), start_blk, 1, addr_tmp) != 1) { // write 1 block
+			free(addr_tmp);
+			printf("mmc write 1 block fail\n");
+			return 1;
+		}
+		free(addr_tmp);
+	}
+	//printf("%#llx blocks , %#llx bytes written: %s\n", n, sz_byte, (n==cnt) ? "OK" : "ERROR");
+	return (n == cnt) ? 0 : 1;
+}
+
+
+static int storage_byte_erase(struct mmc *mmc,loff_t off, size_t  size) {
+
+	int blk_shift = 0;
+	u64 cnt = 0, n = 0, blk = 0;
+
+	blk_shift =  ffs(mmc->read_bl_len) - 1;
+	blk = off >>  blk_shift ;
+	cnt = size >>  blk_shift ;
+	mmc_init(mmc);
+	pr_info("blk:%lld   cnt:%lld \n",blk,cnt);
+	if (cnt)
+		n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
+	printf("%lld blocks erased: %s\n", cnt, (n == 0) ? "OK" : "ERROR");
+	return (n == 0) ? 0 : 1;
+}
+
+static int storage_erase_in_part(char const *part_name, loff_t off, size_t size)
+{
+	int ret = 1;
+	struct mmc *mmc;
+	loff_t offset;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	ret = storage_range_check(mmc,part_name, off, &size, &offset);
+	if (ret)
+		return ret;
+
+	ret = storage_byte_erase(mmc, offset, size);
+	return (ret == 0) ? 0 : 1;
+}
+
+
+
+static int storage_read_in_part(char const *part_name, loff_t off, size_t size, void *dest)
+{
+	int ret =1;
+	struct mmc *mmc;
+	loff_t offset;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	ret = storage_range_check(mmc,part_name,off,&size,&offset);
+
+	if (ret) return ret;
+
+	ret = storage_byte_read(mmc, offset, size, dest);
+
+	return ret;
+}
+
+
+static int storage_write_in_part(char const *part_name, loff_t off, size_t size, void *source)
+{
+	int ret = 1;
+	loff_t offset;
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		printf("Cannot find mmc. \n");
+		return 1;
+	}
+	ret = storage_range_check(mmc,part_name, off, &size, &offset);
+	if (ret) return ret;
+
+	ret = storage_byte_write(mmc, offset, size, source);
+	return ret;
+}
+
+static int storage_mmc_erase_user(struct mmc *mmc) {
+	int ret = 0, i;
+	struct partitions *part_info = NULL;
+
+	if (info_disprotect & DISPROTECT_KEY) {//key disprotect,erase all
+		ret = blk_derase(mmc_get_blk_desc(mmc), 0, 0);
+	} else {//key protect partition with the protect_flag
+		for (i = 0;;i++) {
+			part_info = get_partition_info_by_num(i);
+			if (part_info == NULL)
+				break;
+			if (!strcmp("reserved", part_info->name)) {
+				printf("Part:reserved is skiped\n");
+				continue;
+			}
+			if (part_info->mask_flags & PART_PROTECT_FLAG) {
+				printf("Part:%s is protected\n", part_info->name);
+				continue;
+			}
+			ret = blk_derase(mmc_get_blk_desc(mmc),
+					part_info->offset / BLOCK_SIZE,
+					part_info->size / BLOCK_SIZE);
+			printf("Erased: %s %s\n",
+					part_info->name,
+					(ret == 0)? "OK" : "ERR");
+		}
+	}
+	printf("User partition erased: %s\n", (ret == 0) ? "OK" : "ERROR");
+	return ret;
+}
+
+static int storage_mmc_erase(int flag, struct mmc *mmc) {
+
+	int ret = 0;
+	loff_t off = 0;
+	size_t size = 0;
+
+	if (flag >= ERASE_ALL) {//erase all except reserved
+		ret = storage_mmc_erase_user(mmc);
+		if (ret != 0) {
+			return -1;
+		}
+
+		ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, BOOT0_PARTITION);
+		if (ret) goto R_SWITCH_BACK;
+		ret = blk_derase(mmc_get_blk_desc(mmc), 0, 0);
+		printf("boot0 partition erased: %s\n", (ret == 0) ? "OK" : "ERROR");
+
+		ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, BOOT1_PARTITION);
+
+		if (ret) goto R_SWITCH_BACK;
+		ret = blk_derase(mmc_get_blk_desc(mmc), 0, 0);
+		printf("boot1 partition erased: %s\n", (ret == 0) ? "OK" : "ERROR");
+R_SWITCH_BACK:
+		ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+
+	} else if (flag == ERASE_RESERVED) {//erase reserved
+
+		info_disprotect |= DISPROTECT_KEY;
+		ret = storage_rsv_range_check("reserved", &size, &off);
+		if (ret != 0) {
+			return -1;
+		}
+		ret = storage_erase_in_part("reserved", off, size);
+		info_disprotect &= ~DISPROTECT_KEY;
+	}
+
+	return ret;
+
+
+}
+
+
+
+int mmc_storage_init(unsigned char init_flag) {
+
+	int ret =1;
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	mmc->has_init=0;
+	pinctrl_select_state(mmc->dev, "default");
+	if (!mmc) {
+		return -1;
+	}
+	ret = mmc_init(mmc);
+	if (ret != 0) {
+		return -1;
+	}
+	ret = storage_mmc_erase(init_flag, mmc);
+	return ret;
+}
+
+
+
+
+
+uint64_t mmc_storage_get_part_size(const char *part_name) {
+
+	struct partitions *part_info = NULL;
+
+	part_info = find_mmc_partition_by_name(part_name);
+
+	if (part_info == NULL) {
+		printf("get partition info failed !!\n");
+		return -1;
+	}
+	return part_info->size;
+}
+
+int mmc_storage_read(const char *part_name, loff_t off, size_t size, void *dest) {
+
+	int ret=1;
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+
+	if (!mmc)
+		return 1;
+
+	if (!part_name) {//the operating object is the device,the unit of operation is block.
+		info_disprotect |= DISPROTECT_KEY;
+		ret = blk_dread(mmc_get_blk_desc(mmc), off, size, dest);
+		info_disprotect &= ~DISPROTECT_KEY;
+		printf("%d blocks read: %s\n", ret, (ret == size) ? "OK" : "ERROR");
+		return (ret == size) ? 0 : 1;
+
+	} else {//the opering object is partition,the unit of operation is byte.
+		ret = storage_read_in_part(part_name, off,size, dest);
+	}
+
+	return ret;
+
+}
+
+
+int mmc_storage_write(const char *part_name, loff_t off, size_t size, void *source) {
+
+	int ret=1;
+
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	if (!part_name) {//the operating object is the device,the unit of operation is block.
+		info_disprotect |= DISPROTECT_KEY;
+		ret = blk_dwrite(mmc_get_blk_desc(mmc), off, size, source);
+		info_disprotect &= ~DISPROTECT_KEY;
+		printf("%d blocks written: %s\n", ret, (ret == size) ? "OK" : "ERROR");
+		return (ret == size) ? 0 : 1;
+	} else {//the opering object is partition,the unit of operation is byte.
+		ret = storage_write_in_part(part_name, off, size, source);
+	}
+	return ret;
+}
+
+int mmc_storage_erase(const char *part_name, loff_t off, size_t size, int scrub_flag) {
+
+	int ret=1;
+	struct mmc *mmc;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc)
+		return 1;
+
+	if (!part_name) {//the operating object is the device,the unit of operation is block.
+		ret = storage_mmc_erase(ERASE_ALL, mmc);
+		return (ret == 0) ? 0 : 1;
+	} else {//the opering object is partition,the unit of operation is byte.
+		ret = storage_erase_in_part(part_name, off, size);
+	}
+	return ret;
+}
+
+uint8_t mmc_storage_get_copies(const char *part_name) {
+
+	char ret=3;
+
+	return ret;
+
+}
+
+
+uint64_t mmc_get_copy_size(const char *part_name) {
+
+	struct partitions *part_info = NULL;
+
+#ifdef CONFIG_AML_GPT
+	return UBOOT_SIZE*512;
+#else
+	part_info = find_mmc_partition_by_name("bootloader");
+	if (part_info == NULL) {
+		printf("get partition info failed !!\n");
+		return -1;
+	}
+	return part_info->size;
+#endif
+}
+
+/* dtb read&write operation with backup updates */
+static u32 _calc_boot_info_checksum(struct storage_emmc_boot_info *boot_info)
+{
+	u32 *buffer = (u32*)boot_info;
+	u32 checksum = 0;
+	int i = 0;
+
+	do {
+		checksum += buffer[i];
+	} while (i++ < ((EMMC_BOOT_INFO_SIZE >> 2) - 2));
+
+	return checksum;
+}
+
+static int fill_mask8_part(struct part_property *mask8)
+{
+	struct partitions *part;
+	int i = 0, mask8_cnt = 0;
+
+	part = get_partition_info_by_num(i);
+	while (part) {
+		if ((part->mask_flags == 8)
+			&& (mask8_cnt++ < BOOTINFO_MAX_PARTITIONS)) {
+			strncpy(mask8->name, part->name, strlen(part->name));
+			mask8->addr = part->offset / MMC_BLOCK_SIZE;
+			mask8->size = part->size / MMC_BLOCK_SIZE;
+			mask8++;
+		}
+		if (mask8_cnt == BOOTINFO_MAX_PARTITIONS)
+			break;
+		i++;
+		part = get_partition_info_by_num(i);
+	}
+
+	return mask8_cnt;
+}
+
+static int amlmmc_write_info_sector(struct mmc *mmc)
+{
+	struct storage_emmc_boot_info *boot_info;
+	struct virtual_partition *ddr_part;
+	struct partitions *part;
+	/* partitons with mask = 8 need to fill to bootinfo */
+	struct part_property *mask8;
+	int mask8_partition_count;
+	u8 *buffer;
+	int ret = 0, i;
+
+	buffer = malloc(MMC_BLOCK_SIZE);
+	if (!buffer)
+		return -ENOMEM;
+
+	memset(buffer, 0, sizeof(*boot_info));
+	boot_info = (struct storage_emmc_boot_info *)buffer;
+	part = aml_get_partition_by_name(MMC_RESERVED_NAME);
+	boot_info->rsv_base_addr = part->offset / MMC_BLOCK_SIZE;
+	ddr_part =  aml_get_virtual_partition_by_name(MMC_DDR_PARAMETER_NAME);
+	boot_info->ddr.addr = ddr_part->offset / MMC_BLOCK_SIZE;
+	boot_info->ddr.size = ddr_part->size / MMC_BLOCK_SIZE;
+
+	mask8 = boot_info->parts;
+	mask8_partition_count = fill_mask8_part(mask8);
+
+	boot_info->version = 1;
+	boot_info->checksum = _calc_boot_info_checksum(boot_info);
+
+	printf("boot_info.rsv_base_addr:\t%04x\n", boot_info->rsv_base_addr);
+	printf("boot_info.ddr.addr:%04x\n", boot_info->ddr.addr);
+	printf("boot_info.ddr.size:%04x\n", boot_info->ddr.size);
+	printf("boot info: parts %d\n", mask8_partition_count);
+	for (i = 0; i < mask8_partition_count; i++) {
+		printf("boot_info.part[%d]\n", i);
+		printf("\t.name:%s\n", boot_info->parts[i].name);
+		printf("\t.addr:%04x\n", boot_info->parts[i].addr);
+		printf("\t.size:%04x\n", boot_info->parts[i].size);
+	}
+	printf("boot_info.version:%04x\n", boot_info->version);
+	printf("boot_info.checksum:%04x\n", boot_info->checksum);
+
+	if (blk_dwrite(mmc_get_blk_desc(mmc), 0, 1, buffer) != 1)
+		ret = -EIO;
+
+	free(buffer);
+	return ret;
+}
+
+int mmc_boot_read(const char *part_name, uint8_t cpy, size_t size, void *dest) {
+
+	char ret=1;
+	int i;
+
+	if (cpy == 0)
+		cpy = 1;
+	else if (cpy == 1)
+		cpy = 2;
+	else if (cpy == 2)
+		cpy = 4;
+	else if (cpy == 0xff)
+		cpy = 7;
+	for (i=0;i<3;i++) {//cpy:
+
+		if (cpy & 1) {
+			ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, i);
+			if (ret) goto R_SWITCH_BACK;
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+			ret = storage_read_in_part(part_name, 0, size, dest);
+
+			if (ret != 0) {
+				printf("storage read bootloader failed \n");
+				goto R_SWITCH_BACK;
+			}
+		}
+		cpy = cpy >> 1;
+	}
+
+
+R_SWITCH_BACK:
+	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+	if (ret != 0) {
+		printf("switch part  failed \n");
+		return -1;
+	}
+
+	return ret;
+
+}
+
+int mmc_boot_write(const char *part_name, uint8_t cpy, size_t size, void *source) {
+
+	char ret=1;
+	int i = 0;
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+
+	if (cpy == 0)
+		cpy = 1;
+	else if (cpy == 1)
+		cpy = 2;
+	else if (cpy == 2)
+		cpy = 4;
+	else if (cpy == 0xff)
+		cpy = 7;
+
+	for (i=0;i<3;i++) {//cpy:bin 100 is oprate boot1,bin 010 is oprate boot0,bin 001 is oprate user bootloader.bin 111 is operate all boot.
+
+		if (cpy & 1) {
+			ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, i);
+			if (ret) goto W_SWITCH_BACK;
+#ifdef CONFIG_EMMC_BOOT1_TOUCH_REGION
+			if (i == 2) {
+				size = CONFIG_EMMC_BOOT1_TOUCH_REGION;
+			}
+#endif
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+			ret = storage_write_in_part(part_name, 0, size, source);
+
+			if (ret != 0) {
+				printf("storage write bootloader failed \n");
+				goto W_SWITCH_BACK;
+			}
+			if (i != 0)
+				amlmmc_write_info_sector(mmc);
+		}
+		cpy = cpy >> 1;
+	}
+
+
+W_SWITCH_BACK:
+	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+	if (ret != 0) {
+		printf("switch part failed \n");
+		return -1;
+	}
+
+	return ret;
+
+}
+
+int mmc_boot_erase(const char *part_name, uint8_t cpy) {
+
+	char ret=1;
+	int i;
+	size_t size = 0;
+
+	if (cpy == 0)
+		cpy = 1;
+	else if (cpy == 1)
+		cpy = 2;
+	else if (cpy == 2)
+		cpy = 4;
+	else if (cpy == 0xff)
+		cpy = 7;
+	for (i=0;i<3;i++) {//cpy:
+
+		if (cpy & 1) {
+			ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, i);
+			if (ret) goto E_SWITCH_BACK;
+#ifdef CONFIG_EMMC_BOOT1_TOUCH_REGION
+			if (i == 2) {
+				size = CONFIG_EMMC_BOOT1_TOUCH_REGION;
+			}
+#endif
+#ifdef CONFIG_AML_GPT
+			if (i == 0)
+				continue;
+#endif
+			ret = storage_erase_in_part(part_name, 0, size);
+
+			if (ret != 0) {
+				printf("storage read bootloader failed \n");
+				goto E_SWITCH_BACK;
+			}
+		}
+		cpy = cpy >> 1;
+	}
+
+
+E_SWITCH_BACK:
+	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, STORAGE_EMMC, USER_PARTITION);
+	if (ret != 0) {
+		printf("switch part faild \n");
+		return -1;
+	}
+
+
+	return ret;
+}
+
+uint32_t mmc_get_rsv_size(const char *rsv_name) {
+
+	struct virtual_partition *vpart = NULL;
+	vpart = aml_get_virtual_partition_by_name(rsv_name);
+	printf("the %s partition size is:%llx   byte\n",rsv_name,vpart->size);
+	return vpart->size;
+
+}
+
+static inline int env_read(size_t size, void *buf) {
+	return storage_read_in_part("env", 0, size, buf);
+}
+
+static inline int env_write(size_t size, void *buf) {
+	return storage_write_in_part("env", 0, size, buf);
+}
+
+int mmc_read_rsv(const char *rsv_name, size_t size, void *buf) {
+
+	char ret=1;
+	struct mmc *mmc;
+	loff_t off =0;
+	/*unsigned long dtImgAddr = simple_strtoul(buf, NULL, 16);*/
+	ret = !strcmp("env", rsv_name) || !strcmp("key", rsv_name)
+		|| !strcmp("dtb", rsv_name)||!strcmp("fastboot", rsv_name)
+		||!strcmp("ddr-parameter", rsv_name);
+	if (!ret) return 1;
+
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	if (!strcmp("env", rsv_name)) {
+		ret = env_read(size, buf);
+		return ret;
+	}
+
+	ret = storage_rsv_range_check(rsv_name, &size, &off);
+	if (ret) return ret;
+	if (!strcmp("dtb", rsv_name)) {
+		ret = dtb_read(buf);
+		return ret;
+	}
+
+	if (!strcmp("key", rsv_name))
+		info_disprotect |= DISPROTECT_KEY;
+	ret = storage_byte_read(mmc, off, size, buf);
+	if (!strcmp("key", rsv_name))
+		info_disprotect &= ~DISPROTECT_KEY;
+	if (ret != 0) {
+		printf("read resv failed\n");
+	}
+
+	return ret;
+}
+int mmc_write_rsv(const char *rsv_name, size_t size, void *buf) {
+
+	char ret=1;
+
+	struct mmc *mmc;
+	loff_t off = 0;
+
+	ret = !strcmp("env", rsv_name) || !strcmp("key", rsv_name)
+		|| !strcmp("dtb", rsv_name)||!strcmp("fastboot", rsv_name)
+		||!strcmp("ddr-parameter", rsv_name);
+	if (!ret)
+		return 1;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+
+	if (!strcmp("env", rsv_name)) {
+		ret = env_write(size, buf);
+		return ret;
+	}
+
+	ret = storage_rsv_range_check(rsv_name, &size, &off);
+	if (ret) return ret;
+
+	if (!strcmp("dtb", rsv_name)) {
+		ret = dtb_write(buf);
+		ret |= renew_partition_tbl(buf);
+	} else {
+		if (!strcmp("key", rsv_name))
+			info_disprotect |= DISPROTECT_KEY;
+		ret = storage_byte_write(mmc, off, size, buf);
+		if (!strcmp("key", rsv_name))
+			info_disprotect &= ~DISPROTECT_KEY;
+	}
+
+	if (ret != 0)
+		printf("write rsv failed\n");
+
+	return ret;
+}
+int mmc_erase_rsv(const char *rsv_name) {
+
+	char ret=1;
+	struct mmc *mmc;
+	loff_t off = 0;
+	size_t size = 0;
+	ret = !strcmp("key", rsv_name) || !strcmp("dtb", rsv_name)
+		||!strcmp("fastboot", rsv_name)
+		||!strcmp("ddr-parameter", rsv_name);
+	if (!ret) return 1;
+	mmc = find_mmc_device(STORAGE_EMMC);
+	if (!mmc) {
+		puts("no mmc devices available\n");
+		return 1;
+	}
+	ret = storage_rsv_range_check(rsv_name, &size, &off);
+	if (ret) return ret;
+	if (!strcmp("key", rsv_name))
+		info_disprotect |= DISPROTECT_KEY;
+	ret = storage_byte_erase(mmc, off, size);
+	if (!strcmp("key", rsv_name))
+		info_disprotect &= ~DISPROTECT_KEY;
+	if (ret != 0) {
+		printf("erase resv failed\n");
+	}
+	return ret;
+}
+
+int mmc_protect_rsv(const char *rsv_name, bool ops) {
+
+	char ret=1;
+	ret = strcmp("key", rsv_name);
+	if (ret) return 1;
+
+	if (ops) {
+
+		info_disprotect &= ~DISPROTECT_KEY;
+		printf("Protect the key partition!\n");
+	} else {
+		info_disprotect |= DISPROTECT_KEY;
+		printf("Disprotect the key partition!\n");
+	}
+	return ret;
+
+}
+
+void config_storage_dev_func(struct storage_t *dev, struct mmc* mmc)
+{
+	/******basic info*******/
+	dev->type = BOOT_EMMC;
+	printf("store flag: %d, types: %d\n", dev->init_flag, dev->type);
+	/*dev->info.name = mmc->cid[0] & 0xff,
+		(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
+		(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff;
+	dev->info.id = mmc->cid[0] >> 24;*/
+	dev->info.read_unit = mmc->read_bl_len;
+	dev->info.write_unit = mmc->write_bl_len;
+	dev->info.erase_unit = mmc->erase_grp_size;
+	dev->info.caps = mmc->capacity_user;
+	dev->info.mode = COMPACT_BOOTLOADER;
+
+	dev->get_part_size = mmc_storage_get_part_size;
+	dev->read = mmc_storage_read;
+	dev->write = mmc_storage_write;
+	dev->erase = mmc_storage_erase;
+
+	dev->get_copies = mmc_storage_get_copies;
+	dev->get_copy_size = mmc_get_copy_size;
+	dev->boot_read = mmc_boot_read;
+	dev->boot_write = mmc_boot_write;
+	dev->boot_erase = mmc_boot_erase;
+
+	dev->get_rsv_size = mmc_get_rsv_size;
+	dev->read_rsv = mmc_read_rsv;
+	dev->write_rsv = mmc_write_rsv;
+	dev->erase_rsv = mmc_erase_rsv;
+	dev->protect_rsv = mmc_protect_rsv;
+
+	return;
+}
+
+DECLARE_GLOBAL_DATA_PTR;
+int sdcard_pre(void)
+{
+	return 0;
+}
+
+
+int sdcard_probe(uint32_t init_flag)
+{
+	return 0;
+}
+
+int emmc_pre(void)
+{
+	char ret = 1;
+	struct mmc *mmc;
+	static struct storage_t *storage_dev = NULL;
+
+	mmc_initialize(gd->bd);
+	mmc = find_mmc_device(STORAGE_EMMC);
+	mmc->has_init = 0;
+	ret = mmc_start_init(mmc);
+	if (ret == 0) {
+	/*struct store_operation *storage_opera = NULL;*/
+		storage_dev = kzalloc(sizeof(struct storage_t), GFP_KERNEL);
+		if (storage_dev == NULL) {
+			printf("malloc failed for storage_dev\n");
+			ret = -1;
+			return ret;
+		}
+		config_storage_dev_func(storage_dev, mmc);
+		store_register(storage_dev);
+		printf("emmc init success!\n");
+	} else
+		printf("emmc init fail!\n");
+	return ret;
+}
+
+
+int emmc_probe(uint32_t init_flag)
+{
+	char ret = 0;
+
+	ret = mmc_storage_init(init_flag); /*flag 0*/
+	if (ret) {
+		printf("mmc init failed ret:%x\n", ret);
+		goto exit_error;
+	}
+	printf("emmc probe success\n");
+
+exit_error:
+	return ret;
+}
+
-- 
2.34.1


From 6f7698431132896c584765ef3577a6226cd059ad Mon Sep 17 00:00:00 2001
From: Viacheslav Bocharov <adeep@lexina.in>
Date: Wed, 18 Jan 2023 11:31:33 +0300
Subject: [PATCH 04/17] jethome-emmc: Add common dt/partition functions

Signed-off-by: Viacheslav Bocharov <adeep@lexina.in>
---
 common/Makefile     |   3 +
 common/aml_dt.c     | 600 ++++++++++++++++++++++++++++++++++++++++++++
 common/partitions.c | 206 +++++++++++++++
 3 files changed, 809 insertions(+)
 create mode 100644 common/aml_dt.c
 create mode 100644 common/partitions.c

diff --git a/common/Makefile b/common/Makefile
index 252e9656df..bc3441c9ee 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -11,6 +11,9 @@ obj-y += exports.o
 obj-$(CONFIG_HUSH_PARSER) += cli_hush.o
 obj-$(CONFIG_AUTOBOOT) += autoboot.o
 
+obj-$(CONFIG_AML_STORAGE) += partitions.o
+obj-$(CONFIG_AML_STORAGE) += aml_dt.o
+
 # # boards
 obj-y += board_f.o
 obj-y += board_r.o
diff --git a/common/aml_dt.c b/common/aml_dt.c
new file mode 100644
index 0000000000..a6888999d4
--- /dev/null
+++ b/common/aml_dt.c
@@ -0,0 +1,600 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+* *
+This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+* *
+This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+* *
+You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+* *
+Description:
+*/
+#include <common.h>
+#include <bootm.h>
+#include <command.h>
+#include <image.h>
+#include <malloc.h>
+#include <amlogic/asm/io.h>
+#include <amlogic/asm/secure_apb.h>
+#include <amlstorage/partition_table.h>
+#include <gzip.h>
+
+//#define AML_DT_DEBUG
+#ifdef AML_DT_DEBUG
+#define dbg_printf(...) printf(__VA_ARGS__)
+#else
+#define dbg_printf(...) ((void)0)
+#endif
+
+#define  AML_MULTI_DTB_API_NEW
+//#define AML_MULTI_DTB_CHECK_CMD //command for multi-dtb test
+
+#ifdef AML_MULTI_DTB_API_NEW
+
+/*for multi-dtb gzip buffer*/
+#define GUNZIP_BUF_SIZE         (1<<20)     /*1MB  is enough?*/
+
+/*magic for multi-dtb*/
+#define MAGIC_GZIP_MASK         (0x0000FFFF)
+#define MAGIC_GZIP_ID           (0x00008B1F)
+#define IS_GZIP_PACKED(nMagic)  (MAGIC_GZIP_ID == (MAGIC_GZIP_MASK & nMagic))
+#define MAGIC_DTB_SGL_ID        (0xedfe0dd0)
+#define MAGIC_DTB_MLT_ID        (0x5f4c4d41)
+
+/*amlogic multi-dtb version*/
+#define AML_MUL_DTB_VER_1       (1)
+#define AML_MUL_DTB_VER_2       (2)
+
+/*max char for dtb name, fixed to soc_package_board format*/
+#define AML_MAX_DTB_NAME_SIZE   (128)
+#define AML_DTB_TOKEN_MAX_COUNT (AML_MAX_DTB_NAME_SIZE>>1)
+
+typedef struct{
+	unsigned int nMagic;
+	unsigned int nVersion;
+	unsigned int nDTBCount;
+}st_dtb_hdr_t,*p_st_dtb_hdr_t;
+
+/*v1,v2 multi-dtb only support max to 3 tokens for each DTB name*/
+#define MULTI_DTB_TOKEN_MAX_COUNT      (3)
+#define MULTI_DTB_TOKEN_UNIT_SIZE_V1   (4)      //v1 support 4bytes for each token
+#define MULTI_DTB_TOKEN_UNIT_SIZE_V2   (16)     //v2 support 16bytes for each token
+
+/*v1 multi-dtb*/
+typedef struct{
+	unsigned char     szToken[MULTI_DTB_TOKEN_MAX_COUNT][MULTI_DTB_TOKEN_UNIT_SIZE_V1];
+	int               nDTBOffset;
+	int               nDTBIMGSize;
+}st_dtb_token_v1_t,*p_st_dtb_token_v1_t;
+
+typedef struct{
+	st_dtb_hdr_t      hdr;
+	st_dtb_token_v1_t dtb[1];
+}st_dtb_v1_t,*p_st_dtb_v1_t;
+
+
+/*v2 multi-dtb*/
+typedef struct{
+	unsigned char     szToken[MULTI_DTB_TOKEN_MAX_COUNT][MULTI_DTB_TOKEN_UNIT_SIZE_V2];
+	int               nDTBOffset;
+	int               nDTBIMGSize;
+}st_dtb_token_v2_t,*p_st_dtb_token_v2_t;
+
+typedef struct{
+	st_dtb_hdr_t      hdr;
+	st_dtb_token_v2_t dtb[1];
+}st_dtb_v2_t,*p_st_dtb_v2_t;
+
+
+/*to get the valid DTB index with matched DTB name*/
+static int get_dtb_index(const char aml_dt_buf[128],unsigned long fdt_addr)
+{
+	int nReturn = -1;
+
+	if (!aml_dt_buf)
+		goto exit;
+
+	p_st_dtb_hdr_t pDTBHdr = (p_st_dtb_hdr_t)fdt_addr;
+	char sz_aml_dt_msb[10][MULTI_DTB_TOKEN_UNIT_SIZE_V2];
+	memset(sz_aml_dt_msb,0,sizeof(sz_aml_dt_msb));
+
+	/* split aml_dt with token '_',  e.g "tm2-revb_t962x3_ab301" */
+	//printf("		aml_dt : %s\n",aml_dt_buf);
+
+	char *tokens[AML_DTB_TOKEN_MAX_COUNT];
+	char sz_temp[AML_MAX_DTB_NAME_SIZE+4];
+	memset(tokens,0,sizeof(tokens));
+	memset(sz_temp,0,sizeof(sz_temp));
+	strncpy(sz_temp,aml_dt_buf,128);
+	int i,j;
+	int nLen = strlen(sz_temp);
+	sz_temp[nLen]='_';
+	sz_temp[nLen+1]='\0';
+	nLen +=1;
+	tokens[0]=sz_temp;
+	for (i = 1; i < sizeof(tokens)/sizeof(tokens[0]); i++)
+	{
+		tokens[i] = strstr(tokens[i-1],"_");
+		if (!tokens[i])
+			break;
+
+		*tokens[i]='\0';
+
+		tokens[i]=tokens[i]+1;
+
+		if (!(*tokens[i]))
+		{
+			tokens[i] = 0;
+			break;
+		}
+	}
+
+	//for (i=0;i<10 && tokens[i];++i)
+	//	printf("token-%d:%s\n",i,tokens[i]);
+
+	int nTokenLen = 0;
+
+	switch (pDTBHdr->nVersion)
+	{
+	case AML_MUL_DTB_VER_1:
+	{
+		nTokenLen = MULTI_DTB_TOKEN_UNIT_SIZE_V1;
+	}break;
+	case AML_MUL_DTB_VER_2:
+	{
+		nTokenLen = MULTI_DTB_TOKEN_UNIT_SIZE_V2;
+	}break;
+	default: goto exit; break;
+	}
+
+
+	for (i = 0;i<MULTI_DTB_TOKEN_MAX_COUNT;++i)
+	{
+		if (tokens[i])
+		{
+			char *pbyswap = (char*)sz_aml_dt_msb+(nTokenLen*i);
+			strcpy(pbyswap,tokens[i]);
+			unsigned int nValSwap;
+			for (j = 0;j< nTokenLen;j+=4)
+			{
+				int m;
+				/*swap byte order with unit@4bytes*/
+				nValSwap = *(unsigned int *)(pbyswap+j);
+				for (m=0;m<4;m++)
+					pbyswap[j+m] = (nValSwap >> ((3-m)<<3)) & 0xFF;
+
+				/*replace 0 with 0x20*/
+				for (m=0;m<MULTI_DTB_TOKEN_UNIT_SIZE_V2;++m)
+					if (0 == pbyswap[m])
+						pbyswap[m]=0x20;
+			}
+		}
+		else
+			break;
+	}
+
+	switch (pDTBHdr->nVersion)
+	{
+	case AML_MUL_DTB_VER_1:
+	{
+		p_st_dtb_v1_t pDTB_V1 = (p_st_dtb_v1_t)fdt_addr;
+		for (i=0;i< pDTB_V1->hdr.nDTBCount;++i)
+		{
+			if (!memcmp(pDTB_V1->dtb[i].szToken,sz_aml_dt_msb,
+				MULTI_DTB_TOKEN_MAX_COUNT*nTokenLen))
+			{
+				nReturn = i;
+				break;
+			}
+		}
+
+	}break;
+	case AML_MUL_DTB_VER_2:
+	{
+		p_st_dtb_v2_t pDTB_V2 = (p_st_dtb_v2_t)fdt_addr;
+		for (i=0;i< pDTB_V2->hdr.nDTBCount;++i)
+		{
+			if (!memcmp(pDTB_V2->dtb[i].szToken,sz_aml_dt_msb,
+				MULTI_DTB_TOKEN_MAX_COUNT*nTokenLen))
+			{
+				nReturn = i;
+				break;
+			}
+		}
+
+	}break;
+	default: goto exit; break;
+	}
+
+exit:
+
+	return nReturn;
+
+}
+
+unsigned long __attribute__((unused))	get_multi_dt_entry(unsigned long fdt_addr)
+{
+	unsigned long lReturn = 0; //return buffer for valid DTB;
+	void * gzip_buf = NULL;
+	unsigned long pInputFDT  = fdt_addr;
+	p_st_dtb_hdr_t pDTBHdr   = (p_st_dtb_hdr_t)pInputFDT;
+	unsigned long unzip_size = GUNZIP_BUF_SIZE;
+
+	printf("      Amlogic Multi-DTB tool\n");
+
+	/* first check the blob header, support GZIP format */
+	if ( IS_GZIP_PACKED(pDTBHdr->nMagic))
+	{
+		printf("      GZIP format, decompress...\n");
+		gzip_buf = malloc(GUNZIP_BUF_SIZE);
+		if (!gzip_buf)
+		{
+			printf("      ERROR! fail to allocate memory for GUNZIP...\n");
+			goto exit;
+		}
+		memset(gzip_buf, 0, GUNZIP_BUF_SIZE);
+		if (gunzip(gzip_buf, GUNZIP_BUF_SIZE, (void *)pInputFDT, &unzip_size) < 0)
+		{
+			printf("      ERROR! GUNZIP process fail...\n");
+			goto exit;
+		}
+		if (unzip_size > GUNZIP_BUF_SIZE)
+		{
+			printf("      ERROR! GUNZIP overflow...\n");
+			goto exit;
+		}
+		//memcpy((void*)fdt_addr,gzip_buf,unzip_size);
+		pInputFDT = (unsigned long)gzip_buf;
+		pDTBHdr   = (p_st_dtb_hdr_t)pInputFDT;
+	}
+
+
+	switch (pDTBHdr->nMagic)
+	{
+	case MAGIC_DTB_SGL_ID:
+	{
+		printf("      Single DTB detected\n");
+
+		if (fdt_addr != (unsigned long)pInputFDT) //in case of GZIP single DTB
+			memcpy((void*)fdt_addr,(void*)pInputFDT,unzip_size);
+
+		lReturn = fdt_addr;
+
+	}break;
+	case MAGIC_DTB_MLT_ID:
+	{
+		printf("      Multi DTB detected.\n");
+		printf("      Multi DTB tool version: v%d.\n", pDTBHdr->nVersion);
+		printf("      Support %d DTBS.\n", pDTBHdr->nDTBCount);
+
+
+		/* check and set aml_dt */
+		char aml_dt_buf[AML_MAX_DTB_NAME_SIZE+4];
+		memset(aml_dt_buf, 0, sizeof(aml_dt_buf));
+
+		/* update 2016.07.27, checkhw and setenv everytime,
+		or else aml_dt will set only once if it is reserved */
+		extern int checkhw(char * name);
+#if 1
+		if (checkhw(aml_dt_buf) < 0 || strlen(aml_dt_buf) <= 0)
+		{
+			printf("      Get env aml_dt failed!\n");
+			goto exit;
+		}
+#else
+		char *aml_dt = getenv(AML_DT_UBOOT_ENV);
+		/* if aml_dt not exist or env not ready, get correct dtb by name */
+		if (NULL == aml_dt)
+			checkhw(aml_dt_buf);
+		else
+			memcpy(aml_dt_buf, aml_dt,
+			(strlen(aml_dt)>AML_MAX_DTB_NAME_SIZE?AML_MAX_DTB_NAME_SIZE:(strlen(aml_dt)+1)));
+#endif
+
+		int dtb_match_num = get_dtb_index(aml_dt_buf,(unsigned long)pInputFDT);
+
+		/*check valid dtb index*/
+		if (dtb_match_num < 0 || dtb_match_num >= pDTBHdr->nDTBCount)
+		{
+			printf("      NOT found matched DTB for \"%s\"\n",aml_dt_buf);
+			goto exit;
+		}
+
+		printf("      Found DTB for \"%s\"\n",aml_dt_buf);
+
+		switch (pDTBHdr->nVersion)
+		{
+		case AML_MUL_DTB_VER_1:
+		{
+			p_st_dtb_v1_t pDTB_V1 = (p_st_dtb_v1_t)pInputFDT;
+			lReturn = pDTB_V1->dtb[dtb_match_num].nDTBOffset + pInputFDT;
+
+			if (pInputFDT != fdt_addr)
+			{
+				memcpy((void*)fdt_addr, (void*)lReturn,pDTB_V1->dtb[dtb_match_num].nDTBIMGSize);
+				lReturn = fdt_addr;
+			}
+
+		}break;
+		case AML_MUL_DTB_VER_2:
+		{
+			p_st_dtb_v2_t pDTB_V2 = (p_st_dtb_v2_t)pInputFDT;
+			lReturn = pDTB_V2->dtb[dtb_match_num].nDTBOffset + pInputFDT;
+
+			if (pInputFDT != fdt_addr)
+			{
+				memcpy((void*)fdt_addr, (void*)lReturn,pDTB_V2->dtb[dtb_match_num].nDTBIMGSize);
+				lReturn = fdt_addr;
+			}
+
+		}break;
+		default:
+		{
+			printf("      Invalid Multi-DTB Version [%d]!\n",
+				pDTBHdr->nVersion);
+			goto exit;
+		}break;
+		}
+
+	}break;
+	default: goto exit; break;
+	}
+
+exit:
+
+	if (gzip_buf)
+	{
+		free(gzip_buf);
+		gzip_buf = 0;
+	}
+
+	return lReturn;
+}
+
+#else //#ifdef AML_MULTI_DTB_API_NEW
+
+#define AML_DT_IND_LENGTH_V1		4	/*fixed*/
+#define AML_DT_IND_LENGTH_V2		16	/*fixed*/
+
+#define AML_DT_IND_LENGTH			16
+#define AML_DT_ID_VARI_TOTAL		3	//Total 3 strings
+#define AML_DT_EACH_ID_INT			(AML_DT_IND_LENGTH / 4)
+
+/*Latest version: v2*/
+#define AML_DT_VERSION_OFFSET		4
+#define AML_DT_TOTAL_DTB_OFFSET		8
+#define AML_DT_FIRST_DTB_OFFSET		12
+//#define AML_DT_DTB_HEADER_SIZE	(8+(AML_DT_IND_LENGTH * AML_DT_ID_VARI_TOTAL))
+#define AML_DT_DTB_DT_INFO_OFFSET	0
+//#define AML_DT_DTB_OFFSET_OFFSET	(AML_DT_IND_LENGTH * AML_DT_ID_VARI_TOTAL)
+//#define AML_DT_DTB_SIZE_OFFSET	16
+
+#define AML_DT_UBOOT_ENV	"aml_dt"
+#define DT_HEADER_MAGIC		0xedfe0dd0	/*header of dtb file*/
+#define AML_DT_HEADER_MAGIC	0x5f4c4d41	/*"AML_", multi dtbs supported*/
+
+#define IS_GZIP_FORMAT(data)		((data & (0x0000FFFF)) == (0x00008B1F))
+#define GUNZIP_BUF_SIZE				(0x500000) /* 5MB */
+#define DTB_MAX_SIZE				(AML_DTB_IMG_MAX_SZ)
+
+//#define readl(addr) (*(volatile unsigned int*)(addr))
+extern int checkhw(char * name);
+
+unsigned long __attribute__((unused))
+	get_multi_dt_entry(unsigned long fdt_addr){
+	unsigned int dt_magic = readl(fdt_addr);
+	unsigned int dt_total = 0;
+	unsigned int dt_tool_version = 0;
+	unsigned int gzip_format = 0;
+	void * gzip_buf = NULL;
+	unsigned long dt_entry = fdt_addr;
+
+	printf("      Amlogic multi-dtb tool\n");
+
+	/* first check the file header, support GZIP format */
+	gzip_format = IS_GZIP_FORMAT(dt_magic);
+	if (gzip_format) {
+		printf("      GZIP format, decompress...\n");
+		gzip_buf = malloc(GUNZIP_BUF_SIZE);
+		memset(gzip_buf, 0, GUNZIP_BUF_SIZE);
+		unsigned long unzip_size = GUNZIP_BUF_SIZE;
+		gunzip(gzip_buf, GUNZIP_BUF_SIZE, (void *)fdt_addr, &unzip_size);
+		dbg_printf("      DBG: unzip_size: 0x%x\n", (unsigned int)unzip_size);
+		if (unzip_size > GUNZIP_BUF_SIZE) {
+			printf("      Warning! GUNZIP overflow...\n");
+		}
+		fdt_addr = (unsigned long)gzip_buf;
+		dt_magic = readl(fdt_addr);
+	}
+
+	dbg_printf("      DBG: fdt_addr: 0x%x\n", (unsigned int)fdt_addr);
+	dbg_printf("      DBG: dt_magic: 0x%x\n", (unsigned int)dt_magic);
+
+	/*printf("      Process device tree. dt magic: %x\n", dt_magic);*/
+	if (dt_magic == DT_HEADER_MAGIC) {/*normal dtb*/
+		printf("      Single dtb detected\n");
+		if (gzip_format) {
+			memcpy((void *)dt_entry, (void *)fdt_addr, DTB_MAX_SIZE);
+			fdt_addr = dt_entry;
+			if (gzip_buf)
+				free(gzip_buf);
+		}
+		return fdt_addr;
+	}
+	else if (dt_magic == AML_DT_HEADER_MAGIC) {/*multi dtb*/
+		printf("      Multi dtb detected\n");
+		/* check and set aml_dt */
+		int i = 0;
+		char *aml_dt_buf;
+		aml_dt_buf = (char *)malloc(sizeof(char)*64);
+		printf("Multi dtb malloc aml_dt_buf addr = %p\n", aml_dt_buf);
+		memset(aml_dt_buf, 0, sizeof(aml_dt_buf));
+
+		/* update 2016.07.27, checkhw and setenv everytime,
+		or else aml_dt will set only once if it is reserved */
+#if 1
+		checkhw(aml_dt_buf);
+#else
+		char *aml_dt = getenv(AML_DT_UBOOT_ENV);
+		/* if aml_dt not exist or env not ready, get correct dtb by name */
+		if (NULL == aml_dt)
+			checkhw(aml_dt_buf);
+		else
+			memcpy(aml_dt_buf, aml_dt, (strlen(aml_dt)>64?64:(strlen(aml_dt)+1)));
+#endif
+
+		unsigned int aml_dt_len = aml_dt_buf ? strlen(aml_dt_buf) : 0;
+		if (aml_dt_len <= 0) {
+			printf("      Get env aml_dt failed!\n");
+			if (aml_dt_buf)
+				free(aml_dt_buf);
+			if (gzip_buf)
+				free(gzip_buf);
+			return fdt_addr;
+		}
+
+		/*version control, compatible with v1*/
+		dt_tool_version = readl(fdt_addr + AML_DT_VERSION_OFFSET);
+		unsigned int aml_each_id_length=0;
+		unsigned int aml_dtb_offset_offset;
+		unsigned int aml_dtb_header_size;
+		if (dt_tool_version == 1)
+			aml_each_id_length = 4;
+		else if(dt_tool_version == 2)
+			aml_each_id_length = 16;
+
+		aml_dtb_offset_offset = aml_each_id_length * AML_DT_ID_VARI_TOTAL;
+		aml_dtb_header_size = 8+(aml_each_id_length * AML_DT_ID_VARI_TOTAL);
+		printf("      Multi dtb tool version: v%d .\n", dt_tool_version);
+
+		/*fdt_addr + 0x8: num of dtbs*/
+		dt_total = readl(fdt_addr + AML_DT_TOTAL_DTB_OFFSET);
+		printf("      Support %d dtbs.\n", dt_total);
+
+		/* split aml_dt to 3 strings */
+		char *tokens[3] = {NULL, NULL, NULL};
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++) {
+			tokens[i] = strsep(&aml_dt_buf, "_");
+		}
+		//if (aml_dt_buf)
+			//free(aml_dt_buf);
+		printf("        aml_dt soc: %s platform: %s variant: %s\n", tokens[0], tokens[1], tokens[2]);
+
+		/*match and print result*/
+		char **dt_info;
+		dt_info = (char **)malloc(sizeof(char *)*AML_DT_ID_VARI_TOTAL);
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++)
+			dt_info[i] = (char *)malloc(sizeof(char)*aml_each_id_length);
+		unsigned int dtb_match_num = 0xffff;
+		unsigned int x = 0, y = 0, z = 0; //loop counter
+		unsigned int read_data;
+		for (i = 0; i < dt_total; i++) {
+			for (x = 0; x < AML_DT_ID_VARI_TOTAL; x++) {
+				for (y = 0; y < aml_each_id_length; y+=4) {
+					read_data = readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
+						 i * aml_dtb_header_size + AML_DT_DTB_DT_INFO_OFFSET + \
+						 (x * aml_each_id_length) + y);
+					dt_info[x][y+0] = (read_data >> 24) & 0xff;
+					dt_info[x][y+1] = (read_data >> 16) & 0xff;
+					dt_info[x][y+2] = (read_data >> 8) & 0xff;
+					dt_info[x][y+3] = (read_data >> 0) & 0xff;
+				}
+				for (z=0; z<aml_each_id_length; z++) {
+					/*fix string with \0*/
+					if (0x20 == (uint)dt_info[x][z]) {
+						dt_info[x][z] = '\0';
+					}
+				}
+				//printf("dt_info[x]: %s\n", dt_info[x]);
+				//printf("strlen(dt_info[x]): %d\n", strlen(dt_info[x]));
+			}
+			if (dt_tool_version == 1)
+				printf("        dtb %d soc: %.4s   plat: %.4s   vari: %.4s\n", i, (char *)(dt_info[0]), (char *)(dt_info[1]), (char *)(dt_info[2]));
+			else if(dt_tool_version == 2)
+				printf("        dtb %d soc: %.16s   plat: %.16s   vari: %.16s\n", i, (char *)(dt_info[0]), (char *)(dt_info[1]), (char *)(dt_info[2]));
+			uint match_str_counter = 0;
+			for (z=0; z<AML_DT_ID_VARI_TOTAL; z++) {
+				/*must match 3 strings*/
+				if (!strncmp(tokens[z], (char *)(dt_info[z]), strlen(tokens[z])) && \
+					(strlen(tokens[z]) == strlen(dt_info[z])))
+					match_str_counter++;
+			}
+			if (match_str_counter == AML_DT_ID_VARI_TOTAL) {
+				//printf("Find match dtb\n");
+				dtb_match_num = i;
+			}
+			for (z=0; z<AML_DT_ID_VARI_TOTAL; z++) {
+				/*clear data for next loop*/
+				memset(dt_info[z], 0, sizeof(aml_each_id_length));
+			}
+		}
+		/*clean malloc memory*/
+		for (i = 0; i < AML_DT_ID_VARI_TOTAL; i++) {
+			if (dt_info[i])
+				free(dt_info[i]);
+		}
+		if (dt_info)
+			free(dt_info);
+
+		/*if find match dtb, return address, or else return main entrance address*/
+		if (0xffff != dtb_match_num) {
+			printf("      Find match dtb: %d\n", dtb_match_num);
+			/*this offset is based on dtb image package, so should add on base address*/
+			fdt_addr = (fdt_addr + readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
+				dtb_match_num * aml_dtb_header_size + aml_dtb_offset_offset));
+			if (gzip_format) {
+				memcpy((void *)dt_entry, (void *)fdt_addr, DTB_MAX_SIZE);
+				fdt_addr = dt_entry;
+				if (gzip_buf)
+					free(gzip_buf);
+			}
+			return fdt_addr;
+		}
+		else{
+			printf("      Not match any dtb.\n");
+			if (gzip_buf)
+				free(gzip_buf);
+			return fdt_addr;
+		}
+	}
+	else {
+		printf("      Cannot find legal dtb!\n");
+		if (gzip_buf)
+			free(gzip_buf);
+		return fdt_addr;
+	}
+}
+#endif //#ifdef AML_MULTI_DTB_API_NEW
+
+extern int check_valid_dts(unsigned char *buffer);
+#ifdef 	AML_MULTI_DTB_CHECK_CMD
+static int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned long loadaddr = 0x1080000;
+
+	if (argc > 1)
+		loadaddr = simple_strtoul(argv[1],NULL,16);
+
+	check_valid_dts((void*)loadaddr);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+   dtb_chk,           //command name
+   2,                 //maxargs
+   0,                 //repeatable
+   do_test,           //command function
+   "multi-dtb check command",             //description
+   "    argv: dtb_chk <dtbLoadaddr> \n"   //usage
+   "    do dtb check, which already loaded at <dtbLoadaddr>.\n"
+);
+#endif //#ifdef 	AML_MULTI_DTB_CHECK_CMD
diff --git a/common/partitions.c b/common/partitions.c
new file mode 100644
index 0000000000..25ad5e447d
--- /dev/null
+++ b/common/partitions.c
@@ -0,0 +1,206 @@
+#include <common.h>
+#include <malloc.h>
+#include <linux/err.h>
+#include <amlstorage/partition_table.h>
+#include <linux/libfdt.h>
+#include <amlogic/asm/bl31_apis.h>
+#include <amlogic/aml_efuse.h>
+
+#ifdef CONFIG_MULTI_DTB
+	extern unsigned long get_multi_dt_entry(unsigned long fdt_addr);
+#endif
+
+struct partitions_data{
+	int nr;
+	struct partitions *parts;
+};
+
+struct partitions *part_table = NULL;
+static int parts_total_num;
+int has_boot_slot = 0;
+int has_system_slot = 0;
+bool dynamic_partition = false;
+bool vendor_boot_partition = false;
+
+int get_partitions_table(struct partitions **table)
+{
+	int ret = 0;
+	if (part_table && parts_total_num) {
+		*table = part_table;
+		ret = parts_total_num;
+	}
+	return ret;
+}
+int get_partition_count(void)
+{
+	return parts_total_num;
+}
+struct partitions *get_partitions(void)
+{
+	return part_table;
+}
+
+void free_partitions(void)
+{
+	if (part_table)
+		free(part_table);
+	part_table = NULL;
+}
+
+#ifndef IS_FEAT_BOOT_VERIFY
+#define IS_FEAT_BOOT_VERIFY() 0
+#endif// #ifndef IS_FEAT_BOOT_VERIFY
+
+/*
+  return 0 if dts is valid
+  other value are falure.
+*/
+int check_valid_dts(unsigned char *buffer)
+{
+	int ret = -__LINE__;
+	char *dt_addr;
+	/* fixme, a work around way */
+	unsigned char *sbuffer = (unsigned char *)env_get_hex("loadaddr", 0x1000000 + 0x100000);
+	/* g12a merge to trunk, use trunk code */
+	//unsigned char *sbuffer = (unsigned char *)0x1000000;
+
+	if (IS_FEAT_BOOT_VERIFY()) {
+		memcpy(sbuffer, buffer, AML_DTB_IMG_MAX_SZ);
+		flush_cache((unsigned long)sbuffer, AML_DTB_IMG_MAX_SZ);
+		ret = aml_sec_boot_check(AML_D_P_IMG_DECRYPT, (long unsigned)sbuffer, AML_DTB_IMG_MAX_SZ, 0);
+		if (ret) {
+			printf("\n %s() %d: Decrypt dtb: Sig Check %d\n", __func__, __LINE__, ret);
+			return -__LINE__;
+		}
+		memcpy(buffer, sbuffer, AML_DTB_IMG_MAX_SZ);
+	}
+#ifdef CONFIG_MULTI_DTB
+	dt_addr = (char *)get_multi_dt_entry((unsigned long)buffer);
+#else
+	dt_addr = (char *)buffer;
+#endif
+	pr_debug("start dts,buffer=%p,dt_addr=%p\n", buffer, dt_addr);
+	ret = fdt_check_header(dt_addr);
+	if ( ret < 0 )
+		printf("%s: %s\n",__func__,fdt_strerror(ret));
+	/* fixme, is it 0 when ok? */
+	return ret;
+}
+
+int get_partition_from_dts(unsigned char *buffer)
+{
+	char *dt_addr;
+	int nodeoffset,poffset=0;
+	int *parts_num;
+	char propname[8];
+	const uint32_t *phandle;
+	const char *uname;
+	const char *usize;
+	const char *umask;
+	int index;
+	int ret = -1;
+
+	if ( buffer == NULL)
+		goto _err;
+
+	ret = check_valid_dts(buffer);
+	printf("%s() %d: ret %d\n",__func__, __LINE__, ret);
+	if ( ret < 0 )
+	{
+		printf("%s() %d: ret %d\n",__func__, __LINE__, ret);
+		goto _err;
+	}
+#ifdef CONFIG_MULTI_DTB
+	dt_addr = (char *)get_multi_dt_entry((unsigned long)buffer);
+#else
+	dt_addr = (char *)buffer;
+#endif
+	nodeoffset = fdt_path_offset(dt_addr, "/partitions");
+	if (nodeoffset < 0)
+	{
+		printf("%s: not find /partitions node %s.\n",__func__,fdt_strerror(nodeoffset));
+		ret = -1;
+		goto _err;
+	}
+	parts_num = (int *)fdt_getprop(dt_addr, nodeoffset, "parts", NULL);
+	printf("parts: %d\n",be32_to_cpup((u32*)parts_num));
+
+	if (parts_num > 0)
+	{
+		part_table = (struct partitions *)malloc(sizeof(struct partitions)*(be32_to_cpup((u32*)parts_num)));
+		if (!part_table) {
+			printk("%s part_table alloc _err\n",__func__);
+			//kfree(data);
+			return -1;
+		}
+		memset(part_table, 0, sizeof(struct partitions)*(be32_to_cpup((u32*)parts_num)));
+		parts_total_num = be32_to_cpup((u32*)parts_num);
+	}
+	dynamic_partition = false;
+	env_set("partiton_mode","normal");
+	vendor_boot_partition = false;
+	env_set("vendor_boot_mode","false");
+	for (index = 0; index < be32_to_cpup((u32*)parts_num); index++)
+	{
+		sprintf(propname,"part-%d", index);
+
+		phandle = fdt_getprop(dt_addr, nodeoffset, propname, NULL);
+		if (!phandle) {
+			printf("don't find  match part-%d\n",index);
+			goto _err;
+		}
+		if (phandle) {
+			poffset = fdt_node_offset_by_phandle(dt_addr, be32_to_cpup((u32*)phandle));
+			if (!poffset) {
+				printf("%s:%d,can't find device node\n",__func__,__LINE__);
+				goto _err;
+			}
+		}
+		uname = fdt_getprop(dt_addr, poffset, "pname", NULL);
+		//printf("%s:%d  uname: %s\n",__func__,__LINE__, uname);
+		/* a string but not */
+		usize = fdt_getprop(dt_addr, poffset, "size", NULL);
+		//printf("%s:%d size: 0x%x  0x%x\n",__func__,__LINE__, be32_to_cpup((u32*)usize), be32_to_cpup((((u32*)usize)+1)));
+		umask = fdt_getprop(dt_addr, poffset, "mask", NULL);
+		//printf("%s:%d mask: 0x%x\n",__func__,__LINE__, be32_to_cpup((u32*)umask));
+		/* fill parition table */
+		if (uname != NULL)
+			memcpy(part_table[index].name, uname, strlen(uname));
+		part_table[index].size = ((unsigned long)be32_to_cpup((u32*)usize) << 32) | (unsigned long)be32_to_cpup((((u32*)usize)+1));
+		part_table[index].mask_flags = be32_to_cpup((u32*)umask);
+		printf("%02d:%10s\t%016llx %01x\n", index, uname, part_table[index].size, part_table[index].mask_flags);
+
+		if (strcmp(uname, "boot_a") == 0) {
+			has_boot_slot = 1;
+			printf("set has_boot_slot = 1\n");
+		}
+		else if (strcmp(uname, "boot") == 0) {
+			has_boot_slot = 0;
+			printf("set has_boot_slot = 0\n");
+		}
+		if (strcmp(uname, "system_a") == 0)
+			has_system_slot = 1;
+		else if (strcmp(uname, "system") == 0)
+			has_system_slot = 0;
+
+		if (strcmp(uname, "super") == 0) {
+			dynamic_partition = true;
+			env_set("partiton_mode","dynamic");
+			printf("enable dynamic_partition\n");
+		}
+
+		if (strncmp(uname, "vendor_boot", 11) == 0) {
+			vendor_boot_partition = true;
+			env_set("vendor_boot_mode","true");
+			printf("enable vendor_boot\n");
+		}
+	}
+	return 0;
+
+_err:
+	if (part_table != NULL) {
+		free(part_table);
+		part_table = NULL;
+	}
+	return ret;
+}
-- 
2.34.1

